{"ast":null,"code":"import { reservationApi } from '@/api';\nimport { isReservationExpired } from '@/utils/date';\nexport default {\n  name: 'AdminReservationDetail',\n  data() {\n    return {\n      loading: false,\n      submitting: false,\n      reservation: null,\n      cancelDialogVisible: false,\n      returnDialogVisible: false,\n      // 强制显示状态值 - 用于覆盖计算属性的显示\n      forcedStatusText: null,\n      forcedStatusType: null,\n      // 添加日期匹配标志\n      dateMatches: false,\n      // 用于记录状态变更\n      statusUpdated: false,\n      forcedStatus: null,\n      // 添加特定预约状态缓存标识\n      reservationStatusCacheKey: ''\n    };\n  },\n  created() {\n    this.fetchReservation();\n\n    // 注册页面刷新事件监听器\n    window.addEventListener('beforeunload', this.saveState);\n  },\n  destroyed() {\n    // 移除事件监听器，避免内存泄漏\n    window.removeEventListener('beforeunload', this.saveState);\n  },\n  mounted() {\n    this.loadReservation();\n  },\n  // 监听路由参数变化，当路由参数变化时重新获取数据\n  watch: {\n    '$route': {\n      handler: function (to, from) {\n        // 如果路由参数发生变化，重新获取数据\n        if (to.params.code !== from.params.code || to.query.reservationNumber !== from.query.reservationNumber) {\n          console.log('路由参数变化，重新获取数据');\n          this.fetchReservation();\n        }\n      },\n      deep: true\n    }\n  },\n  // 在路由参数变化时调用\n  beforeRouteUpdate(to, from, next) {\n    console.log('路由参数更新，重新获取数据');\n    this.fetchReservation();\n    next();\n  },\n  computed: {\n    getStatusTagText() {\n      if (!this.reservation) return '';\n\n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusText) {\n        console.log('Using saved status text:', savedState.statusText);\n        return savedState.statusText;\n      }\n\n      // 调用方法获取状态文本\n      const statusText = this.getStatusText(this.reservation);\n      console.log('Computed status text:', statusText);\n      return statusText;\n    },\n    getStatusTagType() {\n      if (!this.reservation) return '';\n\n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusType) {\n        console.log('Using saved status type:', savedState.statusType);\n        return savedState.statusType;\n      }\n\n      // 调用方法获取状态类型\n      const statusType = this.getStatusType(this.reservation);\n      console.log('Computed status type:', statusType);\n      return statusType;\n    },\n    // 获取显示的状态文本\n    displayStatusText() {\n      // 如果有URL传递的状态参数，最优先使用它\n      if (this.$route.query.displayStatus) {\n        console.log('使用URL传递的状态文本:', this.$route.query.displayStatus);\n        return this.$route.query.displayStatus;\n      }\n\n      // 次高优先级：使用强制状态（针对操作后立即更新）\n      if (this.forcedStatusText) {\n        console.log('使用强制状态文本:', this.forcedStatusText);\n        return this.forcedStatusText;\n      }\n\n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusText) {\n        console.log('使用本地存储的状态文本:', savedState.statusText);\n        return savedState.statusText;\n      }\n\n      // 最低优先级：动态计算状态（实时计算）\n      if (!this.reservation) return '';\n\n      // 在这里添加实时计算逻辑，确保已过期和使用中状态能立即更新\n      // 检查是否已过期\n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      if (endTime < now) {\n        console.log('实时计算：预定已过期');\n        return this.$t('reservation.expired');\n      }\n\n      // 检查是否使用中\n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        console.log('实时计算：预定使用中');\n        return this.$t('reservation.inUse');\n      }\n\n      // 默认为已确认，但如果数据库中确实标记为已取消，则显示取消状态\n      if (this.reservation.status === 'cancelled') {\n        console.log('数据库标记为已取消');\n        return this.$t('reservation.cancelled');\n      }\n      console.log('实时计算：预定已确认');\n      return this.$t('reservation.confirmed');\n    },\n    // 获取显示的状态类型（用于样式）\n    displayStatusType() {\n      // 如果有URL传递的状态类型参数，最优先使用它\n      if (this.$route.query.displayStatusType) {\n        console.log('使用URL传递的状态类型:', this.$route.query.displayStatusType);\n        return this.$route.query.displayStatusType;\n      }\n\n      // 次高优先级：使用强制状态类型（针对操作后立即更新）\n      if (this.forcedStatusType) {\n        console.log('使用强制状态类型:', this.forcedStatusType);\n        return this.forcedStatusType;\n      }\n\n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusType) {\n        console.log('使用本地存储的状态类型:', savedState.statusType);\n        return savedState.statusType;\n      }\n\n      // 最低优先级：动态计算状态类型（实时计算）\n      if (!this.reservation) return '';\n\n      // 实时计算逻辑，与状态文本保持一致\n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      if (endTime < now) {\n        return 'warning';\n      }\n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        return 'primary';\n      }\n\n      // 如果数据库中确实标记为已取消，则显示取消状态类型\n      if (this.reservation.status === 'cancelled') {\n        return 'danger';\n      }\n      return 'success';\n    },\n    formattedStartTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.start_datetime);\n    },\n    formattedEndTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.end_datetime);\n    }\n  },\n  methods: {\n    isReservationExpired,\n    async fetchReservation() {\n      this.loading = true;\n      try {\n        const code = this.$route.params.code;\n        console.log('Fetching reservation with code:', code);\n\n        // 获取URL中的查询参数（用于时间和状态）\n        const startTime = this.$route.query.startTime;\n        const endTime = this.$route.query.endTime;\n        let reservationNumber = this.$route.query.reservationNumber;\n\n        // 如果URL中没有预约序号，尝试从localStorage中获取\n        if (!reservationNumber) {\n          const savedReservationNumber = localStorage.getItem('current_reservation_number');\n          if (savedReservationNumber) {\n            console.log('从localStorage中获取预约序号:', savedReservationNumber);\n            reservationNumber = savedReservationNumber;\n          }\n        }\n\n        // 检查是否强制使用预约序号查询\n        const forceUseReservationNumber = localStorage.getItem('force_use_reservation_number');\n        if (forceUseReservationNumber === 'true') {\n          console.log('强制使用预约序号查询');\n          // 使用后清除标记\n          localStorage.removeItem('force_use_reservation_number');\n        }\n        console.log('URL 时间参数:', startTime, endTime);\n        console.log('预约序号:', reservationNumber);\n\n        // 构建API请求参数\n        let params = {};\n\n        // 添加时间戳参数，确保每次都获取最新数据\n        const timestamp = new Date().getTime();\n        params._t = timestamp;\n        console.log('添加时间戳参数:', timestamp);\n\n        // 只有当同时提供了开始和结束时间才添加到请求参数中\n        if (startTime && endTime) {\n          params.start_time = startTime;\n          params.end_time = endTime;\n          console.log('Including time parameters in API request:', params);\n        }\n\n        // 添加预约序号参数\n        if (reservationNumber) {\n          params.reservation_number = reservationNumber;\n          console.log('Including reservation number in API request:', params);\n        }\n\n        // 如果有预约序号，优先使用预约序号查询\n        if (reservationNumber) {\n          console.log('使用预约序号查询:', reservationNumber);\n          try {\n            const response = await reservationApi.getReservationByNumber(reservationNumber);\n            console.log('通过预约序号查询结果:', response);\n\n            // 如果通过预约序号查询成功，直接使用结果\n            if (response.data && response.data.success) {\n              console.log('通过预约序号查询成功');\n\n              // 获取原始数据\n              this.reservation = response.data.data;\n              console.log('Original reservation data:', this.reservation);\n\n              // 检查是否需要显示预约序号通知\n              const showNotification = localStorage.getItem('show_reservation_number_notification');\n              if (showNotification === 'true') {\n                // 显示预约序号信息\n                this.$notify({\n                  title: '预约详情',\n                  message: `当前查看的是预约序号: ${this.reservation.reservation_number}`,\n                  type: 'info',\n                  duration: 5000\n                });\n                // 使用后清除标记\n                localStorage.removeItem('show_reservation_number_notification');\n              }\n\n              // 重要：从URL参数中获取时间覆盖预约显示时间（这确保显示的时间与列表页一致）\n              if (startTime && endTime) {\n                console.log('使用URL参数覆盖显示时间 - 原始时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n\n                // 保存原始时间以备后用\n                this.originalStartTime = this.reservation.start_datetime;\n                this.originalEndTime = this.reservation.end_datetime;\n\n                // 覆盖显示时间\n                this.reservation.start_datetime = startTime;\n                this.reservation.end_datetime = endTime;\n                console.log('覆盖后的显示时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n              }\n\n              // 添加详细日志，帮助调试状态判断\n              console.log('Status from API:', this.reservation.status);\n              console.log('Current time:', new Date());\n\n              // 确保状态字段正确\n              if (!this.reservation.status) {\n                // 如果API返回的状态为空，默认设置为confirmed\n                console.warn('API returned empty status, setting default to confirmed');\n                this.reservation.status = 'confirmed';\n              }\n\n              // 重要：确保状态字段是正确的\n              console.log(`最终数据库状态: ${this.reservation.status}，展示状态为: ${this.getStatusText(this.reservation)}`);\n              this.loading = false;\n              return;\n            } else {\n              console.warn('通过预约序号查询失败，将使用预约码查询');\n            }\n          } catch (error) {\n            console.error('通过预约序号查询出错:', error);\n            console.warn('将使用预约码查询');\n          }\n        }\n\n        // 使用API进行请求，直接传递预定码和参数\n        console.log('Calling API with code and params:', code, params);\n        const response = await reservationApi.getReservationByCode(code, params);\n        console.log('API Response:', response);\n        if (response.data && response.data.success) {\n          // 获取原始数据\n          this.reservation = response.data.data;\n          console.log('Original reservation data:', this.reservation);\n\n          // 显示预约序号信息（无论通过何种方式查询）\n          if (this.reservation.reservation_number) {\n            this.$notify({\n              title: '预约详情',\n              message: `当前查看的是预约序号: ${this.reservation.reservation_number}`,\n              type: 'info',\n              duration: 5000\n            });\n          }\n\n          // 重要：从URL参数中获取时间覆盖预约显示时间（这确保显示的时间与列表页一致）\n          if (startTime && endTime) {\n            console.log('使用URL参数覆盖显示时间 - 原始时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n\n            // 保存原始时间以备后用\n            this.originalStartTime = this.reservation.start_datetime;\n            this.originalEndTime = this.reservation.end_datetime;\n\n            // 覆盖显示时间\n            this.reservation.start_datetime = startTime;\n            this.reservation.end_datetime = endTime;\n            console.log('覆盖后的显示时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n          }\n\n          // 添加详细日志，帮助调试状态判断\n          console.log('Status from API:', this.reservation.status);\n          console.log('Current time:', new Date());\n\n          // 确保状态字段正确\n          if (!this.reservation.status) {\n            // 如果API返回的状态为空，默认设置为confirmed\n            console.warn('API returned empty status, setting default to confirmed');\n            this.reservation.status = 'confirmed';\n          }\n\n          // 重要：现在只检查当前预约序号对应的缓存状态，不再通用应用\n          if (this.reservation.reservation_number) {\n            // 使用当前预约序号创建缓存键\n            const cacheKey = `reservation_status_${this.reservation.reservation_number}`;\n            const cachedStatus = localStorage.getItem(cacheKey);\n            if (cachedStatus) {\n              try {\n                const statusData = JSON.parse(cachedStatus);\n                console.log('找到预约序号缓存状态:', statusData);\n\n                // 验证是否为当前预约序号的状态\n                if (statusData.reservationNumber === this.reservation.reservation_number) {\n                  // 如果缓存中标记为已取消，则覆盖API返回的状态\n                  if (statusData.dbStatus === 'cancelled' || statusData.forcedStatus === 'cancelled') {\n                    console.log('使用缓存中的已取消状态覆盖API返回状态，仅适用于预约序号:', this.reservation.reservation_number);\n                    this.reservation.status = 'cancelled';\n                    this.forcedStatus = 'cancelled';\n                    this.forcedStatusText = this.$t('reservation.cancelled');\n                    this.forcedStatusType = 'danger';\n                  }\n                } else {\n                  console.log('缓存状态预约序号不匹配，不应用缓存状态');\n                }\n              } catch (e) {\n                console.error('解析缓存状态出错:', e);\n              }\n            }\n          }\n\n          // 重要：确保状态字段是正确的\n          console.log(`最终数据库状态: ${this.reservation.status}，展示状态为: ${this.getStatusText(this.reservation)}`);\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.reservationNotFound');\n          this.$message.error(errorMsg);\n          this.reservation = null;\n        }\n      } catch (error) {\n        console.error('Failed to fetch reservation:', error);\n        this.$message.error(this.$t('error.serverError'));\n        this.reservation = null;\n      } finally {\n        this.loading = false;\n      }\n    },\n    async loadReservation() {\n      try {\n        this.loading = true;\n        // 获取预约码\n        const code = this.$route.params.code;\n        if (!code) {\n          this.error = '预约码不存在';\n          this.loading = false;\n          return;\n        }\n\n        // 构建查询参数，确保传递日期时间参数\n        const params = {};\n\n        // 添加时间戳参数，确保每次都获取最新数据\n        const timestamp = new Date().getTime();\n        params._t = timestamp;\n        console.log('添加时间戳参数:', timestamp);\n\n        // 从URL获取日期时间参数\n        const startTime = this.$route.query.startTime;\n        const endTime = this.$route.query.endTime;\n        if (startTime) {\n          params.start_time = startTime;\n          console.log('查询开始时间:', startTime);\n        }\n        if (endTime) {\n          params.end_time = endTime;\n          console.log('查询结束时间:', endTime);\n        }\n\n        // 获取预约信息\n        const response = await this.$api.reservation.getReservationByCode(code, params);\n        console.log('预约API响应:', response);\n        if (response.success) {\n          this.reservation = response.data;\n\n          // 设置日期匹配标志\n          this.dateMatches = !!response.data.date_matches;\n          console.log('日期是否匹配:', this.dateMatches);\n\n          // 设置预约状态信息\n          if (this.reservation.status === 'confirmed') {\n            this.statusText = this.$t('reservation.confirmed');\n            this.statusType = 'success';\n          } else if (this.reservation.status === 'cancelled') {\n            this.statusText = this.$t('reservation.cancelled');\n            this.statusType = 'danger';\n\n            // 如果日期匹配且状态为cancelled，强制使用取消状态\n            if (this.dateMatches) {\n              this.forcedStatus = 'cancelled';\n              console.log('强制使用取消状态');\n            }\n          }\n\n          // 如果有设备ID，获取设备详情\n          if (this.reservation.equipment_id) {\n            this.loadEquipment(this.reservation.equipment_id);\n          }\n        } else {\n          this.error = response.message || '获取预约信息失败';\n        }\n      } catch (error) {\n        console.error('加载预约详情出错:', error);\n        this.error = '加载预约详情出错: ' + (error.message || error);\n      } finally {\n        this.loading = false;\n      }\n    },\n    formatDateTime(dateString) {\n      if (!dateString) return '-';\n      const date = new Date(dateString);\n      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;\n    },\n    // 获取状态文本\n    getStatusText(reservation) {\n      // 首先检查状态是否直接来自API响应\n      console.log('Checking status from API:', reservation.status);\n\n      // 如果API明确返回了cancelled状态，显示已取消\n      if (reservation.status === 'cancelled') {\n        console.log('Using cancelled status from API');\n        return this.$t('reservation.cancelled');\n      }\n\n      // 其他状态根据时间动态计算\n      if (isReservationExpired(reservation.end_datetime)) {\n        console.log('Calculated status: expired');\n        return this.$t('reservation.expired');\n      }\n\n      // 如果预约正在进行中，显示\"使用中\"\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        console.log('Calculated status: in use');\n        return this.$t('reservation.inUse');\n      }\n\n      // 如果预约已确认且未开始，显示\"已确认\"\n      console.log('Calculated status: confirmed');\n      return this.$t('reservation.confirmed');\n    },\n    // 获取状态类型（样式）\n    getStatusType(reservation) {\n      // 首先检查状态是否直接来自API响应\n      if (reservation.status === 'cancelled') {\n        return 'danger';\n      }\n\n      // 如果预约已过期，返回橙色\n      if (isReservationExpired(reservation.end_datetime)) {\n        return 'warning';\n      }\n\n      // 如果预约正在进行中，返回蓝色\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        return 'primary';\n      }\n\n      // 如果预约已确认且未开始，返回绿色\n      return 'success';\n    },\n    // 判断预约是否正在进行中\n    isReservationInProgress(reservation) {\n      if (!reservation) return false;\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n\n      // 当前时间在开始时间和结束时间之间\n      return now >= start && now <= end;\n    },\n    handleCancel() {\n      this.cancelDialogVisible = true;\n    },\n    handleReturn() {\n      this.returnDialogVisible = true;\n    },\n    async confirmCancel() {\n      this.submitting = true;\n      try {\n        // 检查是否是循环预约的子预约\n        if (this.reservation.recurring_reservation_id) {\n          console.log('Cancelling a child reservation of recurring reservation:', this.reservation.recurring_reservation_id);\n\n          // 获取当前预约的详细信息\n          const reservationCode = this.reservation.reservation_code;\n          const reservationNumber = this.reservation.reservation_number;\n\n          // 取消单个子预约\n          const response = await reservationApi.cancelReservation(reservationCode);\n          console.log('Cancel child reservation response:', response);\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 关键改进：同时保存预约序号的状态\n              if (reservationNumber) {\n                this.saveStatusByReservationNumber(reservationNumber, 'cancelled');\n              }\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm('已成功取消此子预约。是否查看循环预约详情？', '操作成功', {\n                confirmButtonText: '查看循环预约',\n                cancelButtonText: '留在当前页面',\n                type: 'success'\n              }).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`);\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation();\n              });\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 关键改进：同时保存预约序号的状态\n              if (reservationNumber) {\n                this.saveStatusByReservationNumber(reservationNumber, 'cancelled');\n              }\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm('已成功取消此子预约。是否查看循环预约详情？', '操作成功', {\n                confirmButtonText: '查看循环预约',\n                cancelButtonText: '留在当前页面',\n                type: 'success'\n              }).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`);\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation();\n              });\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed');\n              this.$message.error(errorMsg);\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n            }\n          }\n        } else {\n          // 普通预约的取消逻辑\n          // 添加预约序号参数，确保只取消特定的子预约\n          const data = {};\n\n          // 添加预约序号参数，确保只取消特定的子预约\n          if (this.reservation.reservation_number) {\n            data.reservation_number = this.reservation.reservation_number;\n            console.log('预约序号参数存在:', this.reservation.reservation_number);\n          } else {\n            console.warn('预约序号参数不存在，将取消所有具有相同预约码的预约');\n          }\n          console.log('取消预约请求参数:', data);\n          const response = await reservationApi.cancelReservation(this.reservation.reservation_code, data);\n          console.log('Cancel response:', response);\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 直接刷新整个页面，确保获取最新数据\n              console.log('预约已取消，即将刷新页面...');\n\n              // 设置一个短暂的延迟，让用户看到成功消息\n              setTimeout(() => {\n                // 强制刷新整个页面，包括所有资源\n                window.location.href = '#/admin/reservation';\n                window.location.reload(true);\n              }, 1000);\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 直接刷新整个页面，确保获取最新数据\n              console.log('预约已取消，即将刷新页面...');\n\n              // 设置一个短暂的延迟，让用户看到成功消息\n              setTimeout(() => {\n                // 强制刷新整个页面，包括所有资源\n                window.location.href = '#/admin/reservation';\n                window.location.reload(true);\n              }, 1000);\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed');\n              this.$message.error(errorMsg);\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Failed to cancel reservation:', error);\n        this.$message.error(this.$t('error.serverError'));\n        // 关闭取消对话框\n        this.cancelDialogVisible = false;\n      } finally {\n        this.submitting = false;\n      }\n    },\n    async confirmReturn() {\n      this.submitting = true;\n      try {\n        // 使用取消预定的API，但添加early_return参数和预约序号参数\n        const data = {\n          early_return: true\n        };\n\n        // 添加预约序号参数，确保只取消特定的子预约\n        if (this.reservation.reservation_number) {\n          data.reservation_number = this.reservation.reservation_number;\n          console.log('提前归还 - 预约序号参数存在:', this.reservation.reservation_number);\n        } else {\n          console.warn('提前归还 - 预约序号参数不存在，将取消所有具有相同预约码的预约');\n        }\n        console.log('提前归还 - 请求参数:', data);\n        const response = await reservationApi.cancelReservation(this.reservation.reservation_code, data);\n        console.log('Return response:', response);\n        if (response.data && response.data.success) {\n          // 关闭对话框\n          this.returnDialogVisible = false;\n\n          // 显示成功消息\n          this.$message.success(this.$t('reservation.returnSuccess'));\n\n          // 直接重新获取预定信息\n          this.fetchReservation();\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.returnFailed');\n          this.$message.error(errorMsg);\n          this.returnDialogVisible = false;\n        }\n      } catch (error) {\n        console.error('Failed to return equipment:', error);\n        this.$message.error(this.$t('error.serverError'));\n        this.returnDialogVisible = false;\n      } finally {\n        this.submitting = false;\n      }\n    },\n    goBack() {\n      // 使用浏览器的历史记录返回，而不是直接跳转\n      if (window.history.length > 1) {\n        this.$router.go(-1); // 返回上一页\n      } else {\n        // 如果没有历史记录，则导航到预定管理页面\n        this.$router.push('/admin/reservation');\n      }\n    },\n    // 状态保存相关方法\n    saveState() {\n      if (!this.reservation) return;\n\n      // 计算当前状态\n      const statusText = this.getStatusText(this.reservation);\n      const statusType = this.getStatusType(this.reservation);\n\n      // 将状态保存到localStorage\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const state = {\n        statusText,\n        statusType,\n        timestamp: new Date().getTime()\n      };\n      console.log('Saving state to localStorage:', state);\n      localStorage.setItem(stateKey, JSON.stringify(state));\n    },\n    getSavedState() {\n      if (!this.reservation) return null;\n\n      // 从localStorage获取状态\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const savedStateStr = localStorage.getItem(stateKey);\n      if (!savedStateStr) return null;\n      try {\n        const savedState = JSON.parse(savedStateStr);\n        console.log('Retrieved saved state:', savedState);\n\n        // 检查保存的状态是否过期（超过5分钟）\n        const now = new Date().getTime();\n        const fiveMinutes = 5 * 60 * 1000;\n        if (now - savedState.timestamp > fiveMinutes) {\n          console.log('Saved state is expired, removing it');\n          localStorage.removeItem(stateKey);\n          return null;\n        }\n        return savedState;\n      } catch (e) {\n        console.error('Error parsing saved state:', e);\n        return null;\n      }\n    },\n    // 更新URL中的状态参数\n    updateUrlWithNewStatus(newStatus) {\n      console.log('更新URL状态为:', newStatus);\n\n      // 获取当前状态对应的文本和类型\n      let statusText = '';\n      let statusType = '';\n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n      }\n      console.log('新状态文本和类型:', statusText, statusType);\n\n      // 更新路由参数，但不触发路由变化\n      const query = {\n        ...this.$route.query,\n        displayStatus: statusText,\n        displayStatusType: statusType\n      };\n\n      // 更新URL但不重新加载页面\n      this.$router.replace({\n        path: this.$route.path,\n        query\n      }).catch(err => {\n        // 忽略重复导航错误\n        if (err.name !== 'NavigationDuplicated') {\n          throw err;\n        }\n      });\n    },\n    // 强制更新状态显示（用于操作后立即更新UI）\n    forceUpdateStatus(newStatus) {\n      console.log('强制更新状态为:', newStatus);\n\n      // 更新状态文本和类型\n      let statusText = '';\n      let statusType = '';\n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n\n        // 只为当前操作的预约添加永久状态标记，不影响其他预约\n        if (this.reservation && this.reservation.reservation_number) {\n          // 仅使用预约序号作为键保存状态，不再使用预约代码\n          const stateKey = `reservation_status_${this.reservation.reservation_number}`;\n          const state = {\n            statusText: this.$t('reservation.cancelled'),\n            statusType: 'danger',\n            dbStatus: 'cancelled',\n            forcedStatus: 'cancelled',\n            timestamp: new Date().getTime(),\n            permanent: true,\n            reservationNumber: this.reservation.reservation_number\n          };\n          console.log('永久保存特定预约序号的已取消状态:', state);\n          localStorage.setItem(stateKey, JSON.stringify(state));\n        }\n\n        // 确保数据模型中的状态也是正确的\n        if (this.reservation) {\n          this.reservation.status = 'cancelled';\n        }\n\n        // 强制状态文本和类型\n        this.forcedStatusText = statusText;\n        this.forcedStatusType = statusType;\n        this.forcedStatus = 'cancelled';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n\n        // 确保数据模型中的状态也是正确的\n        if (this.reservation) {\n          this.reservation.status = 'confirmed';\n\n          // 如果当前预约曾被标记为取消，则移除该标记\n          if (this.reservation.reservation_number) {\n            const stateKey = `reservation_status_${this.reservation.reservation_number}`;\n            localStorage.removeItem(stateKey);\n          }\n        }\n\n        // 强制状态文本和类型\n        this.forcedStatusText = statusText;\n        this.forcedStatusType = statusType;\n        this.forcedStatus = 'confirmed';\n      }\n\n      // 更新路由状态参数\n      this.updateUrlWithNewStatus(newStatus);\n    },\n    // 修改方法：通过预约序号保存状态\n    saveStatusByReservationNumber(reservationNumber, status) {\n      if (!reservationNumber) return;\n      console.log('通过预约序号保存状态:', reservationNumber, status);\n\n      // 创建缓存键\n      const cacheKey = `reservation_status_${reservationNumber}`;\n      let statusText = '';\n      let statusType = '';\n      if (status === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (status === 'confirmed') {\n        statusText = this.$t('reservation.confirmed');\n        statusType = 'success';\n      }\n\n      // 保存状态到本地存储，确保包含预约序号信息\n      const state = {\n        statusText,\n        statusType,\n        dbStatus: status,\n        forcedStatus: status,\n        timestamp: new Date().getTime(),\n        permanent: true,\n        reservationNumber: reservationNumber\n      };\n      console.log('保存预约序号状态到缓存:', cacheKey, state);\n      localStorage.setItem(cacheKey, JSON.stringify(state));\n    },\n    // 检查URL时间参数是否与预定时间匹配\n    isTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      console.log('比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n\n      // 将所有时间转换为字符串以便比较\n      const formatTime = timeStr => {\n        try {\n          // 处理可能的日期格式\n          const date = new Date(timeStr);\n          if (isNaN(date.getTime())) {\n            // 如果无法解析为日期，直接使用原始字符串\n            return timeStr;\n          }\n\n          // 将日期格式化为 YYYY-MM-DD 的形式\n          const year = date.getFullYear();\n          const month = String(date.getMonth() + 1).padStart(2, '0');\n          const day = String(date.getDate()).padStart(2, '0');\n\n          // 返回日期部分，用于匹配同一天的不同预定\n          return `${year}-${month}-${day}`;\n        } catch (e) {\n          console.error('格式化时间出错:', e);\n          return timeStr;\n        }\n      };\n      const urlStartFormatted = formatTime(urlStartTime);\n      const urlEndFormatted = formatTime(urlEndTime);\n      const resStartFormatted = formatTime(resStartTime);\n      const resEndFormatted = formatTime(resEndTime);\n      console.log('格式化后的时间比较:', {\n        urlStartFormatted,\n        urlEndFormatted,\n        resStartFormatted,\n        resEndFormatted\n      });\n\n      // 判断日期是否匹配（只比较日期部分）\n      const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n      console.log('时间匹配结果:', isMatch);\n      return isMatch;\n    },\n    // 检查URL时间参数是否与预定时间精确匹配（包括时间部分）\n    isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      console.log('精确比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n      try {\n        // 尝试解析日期时间，转换为ISO格式进行精确比较\n        // 注意：我们需要比较的是时间精度而不仅仅是日期\n\n        // 处理URL中的时间参数\n        let urlStart, urlEnd;\n        if (typeof urlStartTime === 'string') {\n          // 如果是ISO格式字符串，直接创建Date对象\n          if (urlStartTime.includes('T')) {\n            urlStart = new Date(urlStartTime);\n          } else {\n            // 如果是\"YYYY-MM-DD HH:MM\"格式，手动解析\n            const parts = urlStartTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlStart = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1,\n              // 月份是0-11\n              parseInt(dateParts[2]), parseInt(timeParts[0]), parseInt(timeParts[1]));\n            } else {\n              urlStart = new Date(urlStartTime);\n            }\n          }\n        } else {\n          urlStart = new Date(urlStartTime);\n        }\n        if (typeof urlEndTime === 'string') {\n          if (urlEndTime.includes('T')) {\n            urlEnd = new Date(urlEndTime);\n          } else {\n            const parts = urlEndTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlEnd = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]), parseInt(timeParts[0]), parseInt(timeParts[1]));\n            } else {\n              urlEnd = new Date(urlEndTime);\n            }\n          }\n        } else {\n          urlEnd = new Date(urlEndTime);\n        }\n\n        // 处理预约中的时间\n        let resStart = new Date(resStartTime);\n        let resEnd = new Date(resEndTime);\n\n        // 将所有时间转换为ISO字符串进行比较（不包括毫秒和时区信息）\n        const formatForCompare = date => {\n          if (isNaN(date.getTime())) {\n            console.error('无效的日期对象:', date);\n            return '';\n          }\n          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n        };\n        const urlStartFormatted = formatForCompare(urlStart);\n        const urlEndFormatted = formatForCompare(urlEnd);\n        const resStartFormatted = formatForCompare(resStart);\n        const resEndFormatted = formatForCompare(resEnd);\n        console.log('格式化后的精确时间比较:', {\n          urlStartFormatted,\n          urlEndFormatted,\n          resStartFormatted,\n          resEndFormatted\n        });\n\n        // 判断时间是否精确匹配\n        const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n        console.log('精确时间匹配结果:', isMatch);\n        return isMatch;\n      } catch (e) {\n        console.error('精确比较时间出错:', e);\n        // 出错时保守返回不匹配\n        return false;\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}