{"ast":null,"code":"import { reservationApi } from '@/api';\nimport { isReservationExpired } from '@/utils/date';\nexport default {\n  name: 'AdminReservationDetail',\n  data() {\n    return {\n      loading: false,\n      submitting: false,\n      reservation: null,\n      cancelDialogVisible: false,\n      returnDialogVisible: false,\n      // 强制显示状态值 - 用于覆盖计算属性的显示\n      forcedStatusText: null,\n      forcedStatusType: null,\n      // 添加日期匹配标志\n      dateMatches: false,\n      // 用于记录状态变更\n      statusUpdated: false,\n      forcedStatus: null\n    };\n  },\n  created() {\n    this.fetchReservation();\n\n    // 注册页面刷新事件监听器\n    window.addEventListener('beforeunload', this.saveState);\n  },\n  destroyed() {\n    // 移除事件监听器，避免内存泄漏\n    window.removeEventListener('beforeunload', this.saveState);\n  },\n  computed: {\n    getStatusTagText() {\n      if (!this.reservation) return '';\n\n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusText) {\n        console.log('Using saved status text:', savedState.statusText);\n        return savedState.statusText;\n      }\n\n      // 调用方法获取状态文本\n      const statusText = this.getStatusText(this.reservation);\n      console.log('Computed status text:', statusText);\n      return statusText;\n    },\n    getStatusTagType() {\n      if (!this.reservation) return '';\n\n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusType) {\n        console.log('Using saved status type:', savedState.statusType);\n        return savedState.statusType;\n      }\n\n      // 调用方法获取状态类型\n      const statusType = this.getStatusType(this.reservation);\n      console.log('Computed status type:', statusType);\n      return statusType;\n    },\n    // 获取显示的状态文本\n    displayStatusText() {\n      // 最高优先级：如果数据库状态是已取消，并且URL时间参数与预定时间匹配，则显示已取消\n      if (this.reservation && this.reservation.status === 'cancelled') {\n        // 检查URL时间参数是否与当前预定匹配（使用date_matches字段）\n        if (this.reservation.date_matches === true) {\n          console.log('数据库状态是已取消且日期匹配（使用后端date_matches），显示已取消状态');\n          return this.$t('reservation.cancelled');\n        }\n\n        // 如果后端没有提供date_matches字段，则进行前端比较\n        const urlStartTime = this.$route.query.startTime;\n        const urlEndTime = this.$route.query.endTime;\n        // 使用原始时间而非覆盖后的时间进行比较\n        const resStartTime = this.reservation.original_start_datetime || this.reservation.start_datetime;\n        const resEndTime = this.reservation.original_end_datetime || this.reservation.end_datetime;\n\n        // 对于精确匹配的情况才显示已取消\n        const isTimeMatching = this.isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime);\n        if (isTimeMatching) {\n          console.log('数据库状态是已取消且时间精确匹配，显示已取消状态');\n          return this.$t('reservation.cancelled');\n        } else {\n          console.log('虽然数据库状态是已取消，但原始时间不匹配，不优先使用已取消状态, 原始时间:', resStartTime, resEndTime, ', URL时间:', urlStartTime, urlEndTime);\n        }\n      }\n\n      // 次高优先级：使用强制状态（针对操作后立即更新）\n      if (this.forcedStatusText) {\n        console.log('使用强制状态文本:', this.forcedStatusText);\n        return this.forcedStatusText;\n      }\n\n      // 三优先级：使用URL传递的状态\n      if (this.$route.query.displayStatus) {\n        console.log('使用URL传递的状态文本:', this.$route.query.displayStatus);\n        return this.$route.query.displayStatus;\n      }\n\n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusText) {\n        console.log('使用本地存储的状态文本:', savedState.statusText);\n        return savedState.statusText;\n      }\n\n      // 最低优先级：动态计算状态（实时计算）\n      if (!this.reservation) return '';\n\n      // 在这里添加实时计算逻辑，确保已过期和使用中状态能立即更新\n      // 首先检查是否被取消\n      if (this.reservation.status === 'cancelled') {\n        console.log('实时计算：预定已取消');\n        return this.$t('reservation.cancelled');\n      }\n\n      // 检查是否已过期\n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      if (endTime < now) {\n        console.log('实时计算：预定已过期');\n        return this.$t('reservation.expired');\n      }\n\n      // 检查是否使用中\n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        console.log('实时计算：预定使用中');\n        return this.$t('reservation.inUse');\n      }\n\n      // 默认为已确认\n      console.log('实时计算：预定已确认');\n      return this.$t('reservation.confirmed');\n    },\n    // 获取显示的状态类型（用于样式）\n    displayStatusType() {\n      // 最高优先级：如果数据库状态是已取消，并且URL时间参数与预定时间匹配，则显示危险类型\n      if (this.reservation && this.reservation.status === 'cancelled') {\n        // 检查URL时间参数是否与当前预定匹配（使用date_matches字段）\n        if (this.reservation.date_matches === true) {\n          console.log('数据库状态是已取消且日期匹配（使用后端date_matches），显示危险类型');\n          return 'danger';\n        }\n\n        // 如果后端没有提供date_matches字段，则进行前端比较\n        const urlStartTime = this.$route.query.startTime;\n        const urlEndTime = this.$route.query.endTime;\n        // 使用原始时间而非覆盖后的时间进行比较\n        const resStartTime = this.reservation.original_start_datetime || this.reservation.start_datetime;\n        const resEndTime = this.reservation.original_end_datetime || this.reservation.end_datetime;\n\n        // 对于精确匹配的情况才显示危险类型\n        const isTimeMatching = this.isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime);\n        if (isTimeMatching) {\n          console.log('数据库状态是已取消且时间精确匹配，显示危险类型');\n          return 'danger';\n        } else {\n          console.log('虽然数据库状态是已取消，但原始时间不匹配，不优先使用危险类型');\n        }\n      }\n\n      // 次高优先级：使用强制状态类型（针对操作后立即更新）\n      if (this.forcedStatusType) {\n        console.log('使用强制状态类型:', this.forcedStatusType);\n        return this.forcedStatusType;\n      }\n\n      // 三优先级：使用URL传递的状态类型\n      if (this.$route.query.displayStatusType) {\n        console.log('使用URL传递的状态类型:', this.$route.query.displayStatusType);\n        return this.$route.query.displayStatusType;\n      }\n\n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusType) {\n        console.log('使用本地存储的状态类型:', savedState.statusType);\n        return savedState.statusType;\n      }\n\n      // 最低优先级：动态计算状态类型（实时计算）\n      if (!this.reservation) return '';\n\n      // 实时计算逻辑，与状态文本保持一致\n      if (this.reservation.status === 'cancelled') {\n        return 'danger';\n      }\n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      if (endTime < now) {\n        return 'warning';\n      }\n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        return 'primary';\n      }\n      return 'success';\n    },\n    formattedStartTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.start_datetime);\n    },\n    formattedEndTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.end_datetime);\n    },\n    // 计算实际显示的状态文本\n    displayStatusText() {\n      // 如果强制状态存在，优先使用\n      if (this.forcedStatus) {\n        if (this.forcedStatus === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        }\n      }\n\n      // 如果状态已经被更新，优先使用更新后的状态\n      if (this.statusUpdated) {\n        return this.statusText;\n      }\n\n      // 从URL参数中获取预设的状态\n      const urlStatus = this.$route.query.displayStatus;\n\n      // 如果日期匹配，优先使用后端返回的状态\n      if (this.dateMatches && this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        } else if (this.reservation.status === 'confirmed') {\n          return this.$t('reservation.confirmed');\n        }\n      }\n\n      // 如果URL中有状态参数并且日期不匹配，使用URL中的状态\n      if (urlStatus && !this.dateMatches) {\n        return urlStatus;\n      }\n\n      // 默认使用后端返回的状态\n      if (this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        } else if (this.reservation.status === 'confirmed') {\n          return this.$t('reservation.confirmed');\n        }\n      }\n      return this.statusText || this.$t('reservation.confirmed');\n    },\n    // 计算实际显示的状态类型\n    displayStatusType() {\n      // 如果强制状态存在，优先使用\n      if (this.forcedStatus) {\n        if (this.forcedStatus === 'cancelled') {\n          return 'danger';\n        }\n      }\n\n      // 如果状态已经被更新，优先使用更新后的状态\n      if (this.statusUpdated) {\n        return this.statusType;\n      }\n\n      // 从URL参数中获取预设的状态类型\n      const urlStatusType = this.$route.query.displayStatusType;\n\n      // 如果日期匹配，优先使用后端返回的状态\n      if (this.dateMatches && this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return 'danger';\n        } else if (this.reservation.status === 'confirmed') {\n          return 'success';\n        }\n      }\n\n      // 如果URL中有状态类型参数并且日期不匹配，使用URL中的状态类型\n      if (urlStatusType && !this.dateMatches) {\n        return urlStatusType;\n      }\n\n      // 默认使用后端返回的状态\n      if (this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return 'danger';\n        } else if (this.reservation.status === 'confirmed') {\n          return 'success';\n        }\n      }\n      return this.statusType || 'success';\n    }\n  },\n  methods: {\n    isReservationExpired,\n    async fetchReservation() {\n      this.loading = true;\n      try {\n        const code = this.$route.params.code;\n        console.log('Fetching reservation with code:', code);\n\n        // 获取URL中的查询参数（用于时间和状态）\n        const startTime = this.$route.query.startTime;\n        const endTime = this.$route.query.endTime;\n        console.log('URL 时间参数:', startTime, endTime);\n\n        // 构建API请求参数\n        let params = {};\n\n        // 只有当同时提供了开始和结束时间才添加到请求参数中\n        if (startTime && endTime) {\n          params.start_time = startTime;\n          params.end_time = endTime;\n          console.log('Including time parameters in API request:', params);\n        }\n\n        // 使用API进行请求，直接传递预定码和参数\n        console.log('Calling API with code and params:', code, params);\n        const response = await reservationApi.getReservationByCode(code, params);\n        console.log('API Response:', response);\n        if (response.data && response.data.success) {\n          // 获取原始数据\n          this.reservation = response.data.data;\n          console.log('Original reservation data:', this.reservation);\n\n          // 重要：从URL参数中获取时间覆盖预约显示时间（这确保显示的时间与列表页一致）\n          if (startTime && endTime) {\n            console.log('使用URL参数覆盖显示时间 - 原始时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n\n            // 保存原始时间以备后用\n            this.originalStartTime = this.reservation.start_datetime;\n            this.originalEndTime = this.reservation.end_datetime;\n\n            // 覆盖显示时间\n            this.reservation.start_datetime = startTime;\n            this.reservation.end_datetime = endTime;\n            console.log('覆盖后的显示时间:', this.reservation.start_datetime, this.reservation.end_datetime);\n          }\n\n          // 添加详细日志，帮助调试状态判断\n          console.log('Status from API:', this.reservation.status);\n          console.log('Current time:', new Date());\n\n          // 确保状态字段正确\n          if (!this.reservation.status) {\n            // 如果API返回的状态为空，默认设置为confirmed\n            console.warn('API returned empty status, setting default to confirmed');\n            this.reservation.status = 'confirmed';\n          }\n\n          // 重要：确保状态字段是正确的\n          console.log(`最终数据库状态: ${this.reservation.status}，展示状态为: ${this.getStatusText(this.reservation)}`);\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.reservationNotFound');\n          this.$message.error(errorMsg);\n          this.reservation = null;\n        }\n      } catch (error) {\n        console.error('Failed to fetch reservation:', error);\n        this.$message.error(this.$t('error.serverError'));\n        this.reservation = null;\n      } finally {\n        this.loading = false;\n      }\n    },\n    formatDateTime(dateString) {\n      if (!dateString) return '-';\n      const date = new Date(dateString);\n      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;\n    },\n    // 获取状态文本\n    getStatusText(reservation) {\n      // 首先检查状态是否直接来自API响应\n      console.log('Checking status from API:', reservation.status);\n\n      // 如果API明确返回了cancelled状态，显示已取消\n      if (reservation.status === 'cancelled') {\n        console.log('Using cancelled status from API');\n        return this.$t('reservation.cancelled');\n      }\n\n      // 其他状态根据时间动态计算\n      if (isReservationExpired(reservation.end_datetime)) {\n        console.log('Calculated status: expired');\n        return this.$t('reservation.expired');\n      }\n\n      // 如果预约正在进行中，显示\"使用中\"\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        console.log('Calculated status: in use');\n        return this.$t('reservation.inUse');\n      }\n\n      // 如果预约已确认且未开始，显示\"已确认\"\n      console.log('Calculated status: confirmed');\n      return this.$t('reservation.confirmed');\n    },\n    // 获取状态类型（样式）\n    getStatusType(reservation) {\n      // 首先检查状态是否直接来自API响应\n      if (reservation.status === 'cancelled') {\n        return 'danger';\n      }\n\n      // 如果预约已过期，返回橙色\n      if (isReservationExpired(reservation.end_datetime)) {\n        return 'warning';\n      }\n\n      // 如果预约正在进行中，返回蓝色\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        return 'primary';\n      }\n\n      // 如果预约已确认且未开始，返回绿色\n      return 'success';\n    },\n    // 判断预约是否正在进行中\n    isReservationInProgress(reservation) {\n      if (!reservation) return false;\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n\n      // 当前时间在开始时间和结束时间之间\n      return now >= start && now <= end;\n    },\n    handleCancel() {\n      this.cancelDialogVisible = true;\n    },\n    handleReturn() {\n      this.returnDialogVisible = true;\n    },\n    async confirmCancel() {\n      this.submitting = true;\n      try {\n        // 检查是否是循环预约的子预约\n        if (this.reservation.recurring_reservation_id) {\n          console.log('Cancelling a child reservation of recurring reservation:', this.reservation.recurring_reservation_id);\n\n          // 获取当前预约的详细信息\n          const reservationCode = this.reservation.reservation_code;\n\n          // 取消单个子预约\n          const response = await reservationApi.cancelReservation(reservationCode);\n          console.log('Cancel child reservation response:', response);\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm('已成功取消此子预约。是否查看循环预约详情？', '操作成功', {\n                confirmButtonText: '查看循环预约',\n                cancelButtonText: '留在当前页面',\n                type: 'success'\n              }).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`);\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation();\n              });\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm('已成功取消此子预约。是否查看循环预约详情？', '操作成功', {\n                confirmButtonText: '查看循环预约',\n                cancelButtonText: '留在当前页面',\n                type: 'success'\n              }).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`);\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation();\n              });\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed');\n              this.$message.error(errorMsg);\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n            }\n          }\n        } else {\n          // 普通预约的取消逻辑\n          const response = await reservationApi.cancelReservation(this.reservation.reservation_code);\n          console.log('Cancel response:', response);\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 直接重新获取预定信息（为了更新其他可能的字段）\n              this.fetchReservation();\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n\n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled';\n\n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled');\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'));\n\n              // 直接重新获取预定信息（为了更新其他可能的字段）\n              this.fetchReservation();\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed');\n              this.$message.error(errorMsg);\n              // 关闭取消对话框\n              this.cancelDialogVisible = false;\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Failed to cancel reservation:', error);\n        this.$message.error(this.$t('error.serverError'));\n        // 关闭取消对话框\n        this.cancelDialogVisible = false;\n      } finally {\n        this.submitting = false;\n      }\n    },\n    async confirmReturn() {\n      this.submitting = true;\n      try {\n        // 使用取消预定的API，但添加early_return参数\n        const response = await reservationApi.cancelReservation(this.reservation.reservation_code, {\n          early_return: true\n        });\n        console.log('Return response:', response);\n        if (response.data && response.data.success) {\n          // 关闭对话框\n          this.returnDialogVisible = false;\n\n          // 显示成功消息\n          this.$message.success(this.$t('reservation.returnSuccess'));\n\n          // 直接重新获取预定信息\n          this.fetchReservation();\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.returnFailed');\n          this.$message.error(errorMsg);\n          this.returnDialogVisible = false;\n        }\n      } catch (error) {\n        console.error('Failed to return equipment:', error);\n        this.$message.error(this.$t('error.serverError'));\n        this.returnDialogVisible = false;\n      } finally {\n        this.submitting = false;\n      }\n    },\n    goBack() {\n      // 使用浏览器的历史记录返回，而不是直接跳转\n      if (window.history.length > 1) {\n        this.$router.go(-1); // 返回上一页\n      } else {\n        // 如果没有历史记录，则导航到预定管理页面\n        this.$router.push('/admin/reservation');\n      }\n    },\n    // 状态保存相关方法\n    saveState() {\n      if (!this.reservation) return;\n\n      // 计算当前状态\n      const statusText = this.getStatusText(this.reservation);\n      const statusType = this.getStatusType(this.reservation);\n\n      // 将状态保存到localStorage\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const state = {\n        statusText,\n        statusType,\n        timestamp: new Date().getTime()\n      };\n      console.log('Saving state to localStorage:', state);\n      localStorage.setItem(stateKey, JSON.stringify(state));\n    },\n    getSavedState() {\n      if (!this.reservation) return null;\n\n      // 从localStorage获取状态\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const savedStateStr = localStorage.getItem(stateKey);\n      if (!savedStateStr) return null;\n      try {\n        const savedState = JSON.parse(savedStateStr);\n        console.log('Retrieved saved state:', savedState);\n\n        // 检查保存的状态是否过期（超过5分钟）\n        const now = new Date().getTime();\n        const fiveMinutes = 5 * 60 * 1000;\n        if (now - savedState.timestamp > fiveMinutes) {\n          console.log('Saved state is expired, removing it');\n          localStorage.removeItem(stateKey);\n          return null;\n        }\n        return savedState;\n      } catch (e) {\n        console.error('Error parsing saved state:', e);\n        return null;\n      }\n    },\n    // 更新URL中的状态参数\n    updateUrlWithNewStatus(newStatus) {\n      console.log('更新URL状态为:', newStatus);\n\n      // 获取当前状态对应的文本和类型\n      let statusText = '';\n      let statusType = '';\n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n      }\n      console.log('新状态文本和类型:', statusText, statusType);\n\n      // 更新路由参数，但不触发路由变化\n      const query = {\n        ...this.$route.query,\n        displayStatus: statusText,\n        displayStatusType: statusType\n      };\n\n      // 更新URL但不重新加载页面\n      this.$router.replace({\n        path: this.$route.path,\n        query\n      }).catch(err => {\n        // 忽略重复导航错误\n        if (err.name !== 'NavigationDuplicated') {\n          throw err;\n        }\n      });\n    },\n    // 强制更新状态显示（用于操作后立即更新UI）\n    forceUpdateStatus(newStatus) {\n      console.log('强制更新状态为:', newStatus);\n\n      // 更新状态文本和类型\n      let statusText = '';\n      let statusType = '';\n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n      }\n      console.log('强制更新后的状态文本和类型:', statusText, statusType);\n\n      // 直接设置强制状态值，立即更新UI\n      this.forcedStatusText = statusText;\n      this.forcedStatusType = statusType;\n\n      // 保存到本地存储，确保刷新页面后状态保持一致\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const state = {\n        statusText,\n        statusType,\n        timestamp: new Date().getTime()\n      };\n      localStorage.setItem(stateKey, JSON.stringify(state));\n\n      // 直接替换URL参数，但不触发路由变化\n      const query = {\n        ...this.$route.query,\n        displayStatus: statusText,\n        displayStatusType: statusType\n      };\n\n      // 替换URL参数\n      this.$router.replace({\n        path: this.$route.path,\n        query\n      }).catch(err => {\n        // 忽略重复导航错误\n        if (err.name !== 'NavigationDuplicated') {\n          throw err;\n        }\n      });\n    },\n    // 检查URL时间参数是否与预定时间匹配\n    isTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      console.log('比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n\n      // 将所有时间转换为字符串以便比较\n      const formatTime = timeStr => {\n        try {\n          // 处理可能的日期格式\n          const date = new Date(timeStr);\n          if (isNaN(date.getTime())) {\n            // 如果无法解析为日期，直接使用原始字符串\n            return timeStr;\n          }\n\n          // 将日期格式化为 YYYY-MM-DD 的形式\n          const year = date.getFullYear();\n          const month = String(date.getMonth() + 1).padStart(2, '0');\n          const day = String(date.getDate()).padStart(2, '0');\n\n          // 返回日期部分，用于匹配同一天的不同预定\n          return `${year}-${month}-${day}`;\n        } catch (e) {\n          console.error('格式化时间出错:', e);\n          return timeStr;\n        }\n      };\n      const urlStartFormatted = formatTime(urlStartTime);\n      const urlEndFormatted = formatTime(urlEndTime);\n      const resStartFormatted = formatTime(resStartTime);\n      const resEndFormatted = formatTime(resEndTime);\n      console.log('格式化后的时间比较:', {\n        urlStartFormatted,\n        urlEndFormatted,\n        resStartFormatted,\n        resEndFormatted\n      });\n\n      // 判断日期是否匹配（只比较日期部分）\n      const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n      console.log('时间匹配结果:', isMatch);\n      return isMatch;\n    },\n    // 检查URL时间参数是否与预定时间精确匹配（包括时间部分）\n    isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      console.log('精确比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n      try {\n        // 尝试解析日期时间，转换为ISO格式进行精确比较\n        // 注意：我们需要比较的是时间精度而不仅仅是日期\n\n        // 处理URL中的时间参数\n        let urlStart, urlEnd;\n        if (typeof urlStartTime === 'string') {\n          // 如果是ISO格式字符串，直接创建Date对象\n          if (urlStartTime.includes('T')) {\n            urlStart = new Date(urlStartTime);\n          } else {\n            // 如果是\"YYYY-MM-DD HH:MM\"格式，手动解析\n            const parts = urlStartTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlStart = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1,\n              // 月份是0-11\n              parseInt(dateParts[2]), parseInt(timeParts[0]), parseInt(timeParts[1]));\n            } else {\n              urlStart = new Date(urlStartTime);\n            }\n          }\n        } else {\n          urlStart = new Date(urlStartTime);\n        }\n        if (typeof urlEndTime === 'string') {\n          if (urlEndTime.includes('T')) {\n            urlEnd = new Date(urlEndTime);\n          } else {\n            const parts = urlEndTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlEnd = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]), parseInt(timeParts[0]), parseInt(timeParts[1]));\n            } else {\n              urlEnd = new Date(urlEndTime);\n            }\n          }\n        } else {\n          urlEnd = new Date(urlEndTime);\n        }\n\n        // 处理预约中的时间\n        let resStart = new Date(resStartTime);\n        let resEnd = new Date(resEndTime);\n\n        // 将所有时间转换为ISO字符串进行比较（不包括毫秒和时区信息）\n        const formatForCompare = date => {\n          if (isNaN(date.getTime())) {\n            console.error('无效的日期对象:', date);\n            return '';\n          }\n          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n        };\n        const urlStartFormatted = formatForCompare(urlStart);\n        const urlEndFormatted = formatForCompare(urlEnd);\n        const resStartFormatted = formatForCompare(resStart);\n        const resEndFormatted = formatForCompare(resEnd);\n        console.log('格式化后的精确时间比较:', {\n          urlStartFormatted,\n          urlEndFormatted,\n          resStartFormatted,\n          resEndFormatted\n        });\n\n        // 判断时间是否精确匹配\n        const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n        console.log('精确时间匹配结果:', isMatch);\n        return isMatch;\n      } catch (e) {\n        console.error('精确比较时间出错:', e);\n        // 出错时保守返回不匹配\n        return false;\n      }\n    }\n  }\n};","map":{"version":3,"names":["reservationApi","isReservationExpired","name","data","loading","submitting","reservation","cancelDialogVisible","returnDialogVisible","forcedStatusText","forcedStatusType","dateMatches","statusUpdated","forcedStatus","created","fetchReservation","window","addEventListener","saveState","destroyed","removeEventListener","computed","getStatusTagText","savedState","getSavedState","statusText","console","log","getStatusText","getStatusTagType","statusType","getStatusType","displayStatusText","status","date_matches","$t","urlStartTime","$route","query","startTime","urlEndTime","endTime","resStartTime","original_start_datetime","start_datetime","resEndTime","original_end_datetime","end_datetime","isTimeMatching","isExactTimeMatching","displayStatus","now","Date","displayStatusType","formattedStartTime","formatDateTime","formattedEndTime","urlStatus","urlStatusType","methods","code","params","start_time","end_time","response","getReservationByCode","success","originalStartTime","originalEndTime","warn","errorMsg","message","$message","error","dateString","date","getFullYear","String","getMonth","padStart","getDate","getHours","getMinutes","start","end","isReservationInProgress","handleCancel","handleReturn","confirmCancel","recurring_reservation_id","reservationCode","reservation_code","cancelReservation","includes","forceUpdateStatus","$confirm","confirmButtonText","cancelButtonText","type","then","$router","push","catch","confirmReturn","early_return","goBack","history","length","go","stateKey","state","timestamp","getTime","localStorage","setItem","JSON","stringify","savedStateStr","getItem","parse","fiveMinutes","removeItem","e","updateUrlWithNewStatus","newStatus","replace","path","err","formatTime","timeStr","isNaN","year","month","day","urlStartFormatted","urlEndFormatted","resStartFormatted","resEndFormatted","isMatch","urlStart","urlEnd","parts","split","dateParts","timeParts","parseInt","resStart","resEnd","formatForCompare"],"sources":["src/views/admin/AdminReservationDetail.vue"],"sourcesContent":["<template>\n  <div class=\"admin-reservation-detail\">\n    <div class=\"page-header\">\n      <h1 class=\"page-title\">{{ $t('reservation.detail') }}</h1>\n      <el-button @click=\"goBack\" icon=\"el-icon-back\">\n        {{ $t('common.back') }}\n      </el-button>\n    </div>\n\n    <div v-if=\"loading\" class=\"loading-container\">\n      <el-skeleton :rows=\"10\" animated />\n    </div>\n\n    <el-card v-else-if=\"!reservation\" class=\"error-card\">\n      <div class=\"error-message\">\n        <i class=\"el-icon-warning-outline\"></i>\n        <p>{{ $t('reservation.reservationNotFound') }}</p>\n      </div>\n      <el-button type=\"primary\" @click=\"goBack\">\n        {{ $t('common.back') }}\n      </el-button>\n    </el-card>\n\n    <div v-else>\n      <!-- 预定详情卡片 -->\n      <el-card shadow=\"hover\" class=\"detail-card\">\n        <div slot=\"header\" class=\"card-header\">\n          <span>{{ $t('reservation.detail') }}</span>\n          <el-tag :type=\"displayStatusType\">\n            {{ displayStatusText }}\n          </el-tag>\n        </div>\n\n        <el-descriptions :column=\"2\" border>\n          <el-descriptions-item :label=\"$t('reservation.code')\">\n            {{ reservation.reservation_code }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.status')\">\n            <el-tag :type=\"displayStatusType\">\n              {{ displayStatusText }}\n            </el-tag>\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.equipmentName')\">\n            <router-link :to=\"`/equipment/${reservation.equipment_id}`\">\n              {{ reservation.equipment_name }}\n            </router-link>\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('common.createTime')\">\n            {{ formatDateTime(reservation.created_at) }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.startTime')\">\n            {{ formatDateTime(reservation.start_datetime) }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.endTime')\">\n            {{ formatDateTime(reservation.end_datetime) }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.userName')\">\n            {{ reservation.user_name }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.userDepartment')\">\n            {{ reservation.user_department }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.userContact')\">\n            {{ reservation.user_contact }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.userEmail')\">\n            {{ reservation.user_email || '-' }}\n          </el-descriptions-item>\n\n          <el-descriptions-item :label=\"$t('reservation.purpose')\" :span=\"2\">\n            {{ reservation.purpose || '-' }}\n          </el-descriptions-item>\n        </el-descriptions>\n\n        <div class=\"actions\">\n          <!-- 已确认且未开始的预约才显示取消按钮 -->\n          <el-button\n            v-if=\"displayStatusText === $t('reservation.confirmed')\"\n            type=\"danger\"\n            @click=\"handleCancel\"\n          >\n            {{ $t('reservation.cancelReservation') }}\n          </el-button>\n\n          <!-- 使用中的预约才显示提前归还按钮 -->\n          <el-button\n            v-if=\"displayStatusText === $t('reservation.inUse')\"\n            type=\"primary\"\n            @click=\"handleReturn\"\n          >\n            {{ $t('reservation.earlyReturn') }}\n          </el-button>\n        </div>\n      </el-card>\n    </div>\n\n    <!-- 取消预定确认对话框 -->\n    <el-dialog\n      :title=\"$t('common.warning')\"\n      :visible.sync=\"cancelDialogVisible\"\n      width=\"30%\"\n    >\n      <span>{{ $t('reservation.confirmCancel') }}</span>\n      <span slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"cancelDialogVisible = false\">{{ $t('common.cancel') }}</el-button>\n        <el-button type=\"danger\" @click=\"confirmCancel\" :loading=\"submitting\">{{ $t('common.confirm') }}</el-button>\n      </span>\n    </el-dialog>\n\n    <!-- 提前归还确认对话框 -->\n    <el-dialog\n      :title=\"$t('reservation.earlyReturn')\"\n      :visible.sync=\"returnDialogVisible\"\n      width=\"30%\"\n    >\n      <span>{{ $t('reservation.confirmEarlyReturn') }}</span>\n      <span slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"returnDialogVisible = false\">{{ $t('common.cancel') }}</el-button>\n        <el-button type=\"primary\" @click=\"confirmReturn\" :loading=\"submitting\">{{ $t('common.confirm') }}</el-button>\n      </span>\n    </el-dialog>\n  </div>\n</template>\n\n<script>\nimport { reservationApi } from '@/api'\nimport { isReservationExpired } from '@/utils/date'\n\nexport default {\n  name: 'AdminReservationDetail',\n\n  data() {\n    return {\n      loading: false,\n      submitting: false,\n      reservation: null,\n      cancelDialogVisible: false,\n      returnDialogVisible: false,\n      // 强制显示状态值 - 用于覆盖计算属性的显示\n      forcedStatusText: null,\n      forcedStatusType: null,\n      // 添加日期匹配标志\n      dateMatches: false,\n      // 用于记录状态变更\n      statusUpdated: false,\n      forcedStatus: null\n    }\n  },\n\n  created() {\n    this.fetchReservation()\n    \n    // 注册页面刷新事件监听器\n    window.addEventListener('beforeunload', this.saveState)\n  },\n  \n  destroyed() {\n    // 移除事件监听器，避免内存泄漏\n    window.removeEventListener('beforeunload', this.saveState)\n  },\n\n  computed: {\n    getStatusTagText() {\n      if (!this.reservation) return ''\n      \n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState()\n      if (savedState && savedState.statusText) {\n        console.log('Using saved status text:', savedState.statusText)\n        return savedState.statusText\n      }\n      \n      // 调用方法获取状态文本\n      const statusText = this.getStatusText(this.reservation)\n      console.log('Computed status text:', statusText)\n      return statusText\n    },\n    \n    getStatusTagType() {\n      if (!this.reservation) return ''\n      \n      // 尝试恢复存储的状态\n      const savedState = this.getSavedState()\n      if (savedState && savedState.statusType) {\n        console.log('Using saved status type:', savedState.statusType)\n        return savedState.statusType\n      }\n      \n      // 调用方法获取状态类型\n      const statusType = this.getStatusType(this.reservation)\n      console.log('Computed status type:', statusType)\n      return statusType\n    },\n    // 获取显示的状态文本\n    displayStatusText() {\n      // 最高优先级：如果数据库状态是已取消，并且URL时间参数与预定时间匹配，则显示已取消\n      if (this.reservation && this.reservation.status === 'cancelled') {\n        // 检查URL时间参数是否与当前预定匹配（使用date_matches字段）\n        if (this.reservation.date_matches === true) {\n          console.log('数据库状态是已取消且日期匹配（使用后端date_matches），显示已取消状态');\n          return this.$t('reservation.cancelled');\n        }\n        \n        // 如果后端没有提供date_matches字段，则进行前端比较\n        const urlStartTime = this.$route.query.startTime;\n        const urlEndTime = this.$route.query.endTime;\n        // 使用原始时间而非覆盖后的时间进行比较\n        const resStartTime = this.reservation.original_start_datetime || this.reservation.start_datetime;\n        const resEndTime = this.reservation.original_end_datetime || this.reservation.end_datetime;\n        \n        // 对于精确匹配的情况才显示已取消\n        const isTimeMatching = this.isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime);\n        \n        if (isTimeMatching) {\n          console.log('数据库状态是已取消且时间精确匹配，显示已取消状态');\n          return this.$t('reservation.cancelled');\n        } else {\n          console.log('虽然数据库状态是已取消，但原始时间不匹配，不优先使用已取消状态, 原始时间:', resStartTime, resEndTime, ', URL时间:', urlStartTime, urlEndTime);\n        }\n      }\n      \n      // 次高优先级：使用强制状态（针对操作后立即更新）\n      if (this.forcedStatusText) {\n        console.log('使用强制状态文本:', this.forcedStatusText);\n        return this.forcedStatusText;\n      }\n      \n      // 三优先级：使用URL传递的状态\n      if (this.$route.query.displayStatus) {\n        console.log('使用URL传递的状态文本:', this.$route.query.displayStatus);\n        return this.$route.query.displayStatus;\n      }\n      \n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusText) {\n        console.log('使用本地存储的状态文本:', savedState.statusText);\n        return savedState.statusText;\n      }\n      \n      // 最低优先级：动态计算状态（实时计算）\n      if (!this.reservation) return '';\n      \n      // 在这里添加实时计算逻辑，确保已过期和使用中状态能立即更新\n      // 首先检查是否被取消\n      if (this.reservation.status === 'cancelled') {\n        console.log('实时计算：预定已取消');\n        return this.$t('reservation.cancelled');\n      }\n      \n      // 检查是否已过期\n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      if (endTime < now) {\n        console.log('实时计算：预定已过期');\n        return this.$t('reservation.expired');\n      }\n      \n      // 检查是否使用中\n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        console.log('实时计算：预定使用中');\n        return this.$t('reservation.inUse');\n      }\n      \n      // 默认为已确认\n      console.log('实时计算：预定已确认');\n      return this.$t('reservation.confirmed');\n    },\n    \n    // 获取显示的状态类型（用于样式）\n    displayStatusType() {\n      // 最高优先级：如果数据库状态是已取消，并且URL时间参数与预定时间匹配，则显示危险类型\n      if (this.reservation && this.reservation.status === 'cancelled') {\n        // 检查URL时间参数是否与当前预定匹配（使用date_matches字段）\n        if (this.reservation.date_matches === true) {\n          console.log('数据库状态是已取消且日期匹配（使用后端date_matches），显示危险类型');\n          return 'danger';\n        }\n        \n        // 如果后端没有提供date_matches字段，则进行前端比较\n        const urlStartTime = this.$route.query.startTime;\n        const urlEndTime = this.$route.query.endTime;\n        // 使用原始时间而非覆盖后的时间进行比较\n        const resStartTime = this.reservation.original_start_datetime || this.reservation.start_datetime;\n        const resEndTime = this.reservation.original_end_datetime || this.reservation.end_datetime;\n        \n        // 对于精确匹配的情况才显示危险类型\n        const isTimeMatching = this.isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime);\n        \n        if (isTimeMatching) {\n          console.log('数据库状态是已取消且时间精确匹配，显示危险类型');\n          return 'danger';\n        } else {\n          console.log('虽然数据库状态是已取消，但原始时间不匹配，不优先使用危险类型');\n        }\n      }\n      \n      // 次高优先级：使用强制状态类型（针对操作后立即更新）\n      if (this.forcedStatusType) {\n        console.log('使用强制状态类型:', this.forcedStatusType);\n        return this.forcedStatusType;\n      }\n      \n      // 三优先级：使用URL传递的状态类型\n      if (this.$route.query.displayStatusType) {\n        console.log('使用URL传递的状态类型:', this.$route.query.displayStatusType);\n        return this.$route.query.displayStatusType;\n      }\n      \n      // 再次优先级：使用本地存储的状态\n      const savedState = this.getSavedState();\n      if (savedState && savedState.statusType) {\n        console.log('使用本地存储的状态类型:', savedState.statusType);\n        return savedState.statusType;\n      }\n      \n      // 最低优先级：动态计算状态类型（实时计算）\n      if (!this.reservation) return '';\n      \n      // 实时计算逻辑，与状态文本保持一致\n      if (this.reservation.status === 'cancelled') {\n        return 'danger';\n      }\n      \n      const now = new Date();\n      const endTime = new Date(this.reservation.end_datetime);\n      \n      if (endTime < now) {\n        return 'warning';\n      }\n      \n      const startTime = new Date(this.reservation.start_datetime);\n      if (now >= startTime && now <= endTime) {\n        return 'primary';\n      }\n      \n      return 'success';\n    },\n    formattedStartTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.start_datetime);\n    },\n    formattedEndTime() {\n      if (!this.reservation) return '';\n      return this.formatDateTime(this.reservation.end_datetime);\n    },\n    // 计算实际显示的状态文本\n    displayStatusText() {\n      // 如果强制状态存在，优先使用\n      if (this.forcedStatus) {\n        if (this.forcedStatus === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        }\n      }\n      \n      // 如果状态已经被更新，优先使用更新后的状态\n      if (this.statusUpdated) {\n        return this.statusText;\n      }\n      \n      // 从URL参数中获取预设的状态\n      const urlStatus = this.$route.query.displayStatus;\n      \n      // 如果日期匹配，优先使用后端返回的状态\n      if (this.dateMatches && this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        } else if (this.reservation.status === 'confirmed') {\n          return this.$t('reservation.confirmed');\n        }\n      }\n      \n      // 如果URL中有状态参数并且日期不匹配，使用URL中的状态\n      if (urlStatus && !this.dateMatches) {\n        return urlStatus;\n      }\n      \n      // 默认使用后端返回的状态\n      if (this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return this.$t('reservation.cancelled');\n        } else if (this.reservation.status === 'confirmed') {\n          return this.$t('reservation.confirmed');\n        }\n      }\n      \n      return this.statusText || this.$t('reservation.confirmed');\n    },\n    // 计算实际显示的状态类型\n    displayStatusType() {\n      // 如果强制状态存在，优先使用\n      if (this.forcedStatus) {\n        if (this.forcedStatus === 'cancelled') {\n          return 'danger';\n        }\n      }\n      \n      // 如果状态已经被更新，优先使用更新后的状态\n      if (this.statusUpdated) {\n        return this.statusType;\n      }\n      \n      // 从URL参数中获取预设的状态类型\n      const urlStatusType = this.$route.query.displayStatusType;\n      \n      // 如果日期匹配，优先使用后端返回的状态\n      if (this.dateMatches && this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return 'danger';\n        } else if (this.reservation.status === 'confirmed') {\n          return 'success';\n        }\n      }\n      \n      // 如果URL中有状态类型参数并且日期不匹配，使用URL中的状态类型\n      if (urlStatusType && !this.dateMatches) {\n        return urlStatusType;\n      }\n      \n      // 默认使用后端返回的状态\n      if (this.reservation) {\n        if (this.reservation.status === 'cancelled') {\n          return 'danger';\n        } else if (this.reservation.status === 'confirmed') {\n          return 'success';\n        }\n      }\n      \n      return this.statusType || 'success';\n    }\n  },\n\n  methods: {\n    isReservationExpired,\n\n    async fetchReservation() {\n      this.loading = true\n\n      try {\n        const code = this.$route.params.code\n        console.log('Fetching reservation with code:', code)\n\n        // 获取URL中的查询参数（用于时间和状态）\n        const startTime = this.$route.query.startTime\n        const endTime = this.$route.query.endTime\n        \n        console.log('URL 时间参数:', startTime, endTime)\n\n        // 构建API请求参数\n        let params = {}\n        \n        // 只有当同时提供了开始和结束时间才添加到请求参数中\n        if (startTime && endTime) {\n          params.start_time = startTime\n          params.end_time = endTime\n          console.log('Including time parameters in API request:', params)\n        }\n\n        // 使用API进行请求，直接传递预定码和参数\n        console.log('Calling API with code and params:', code, params)\n        const response = await reservationApi.getReservationByCode(code, params)\n\n        console.log('API Response:', response)\n\n        if (response.data && response.data.success) {\n          // 获取原始数据\n          this.reservation = response.data.data\n          console.log('Original reservation data:', this.reservation)\n          \n          // 重要：从URL参数中获取时间覆盖预约显示时间（这确保显示的时间与列表页一致）\n          if (startTime && endTime) {\n            console.log('使用URL参数覆盖显示时间 - 原始时间:', this.reservation.start_datetime, this.reservation.end_datetime)\n            \n            // 保存原始时间以备后用\n            this.originalStartTime = this.reservation.start_datetime\n            this.originalEndTime = this.reservation.end_datetime\n            \n            // 覆盖显示时间\n            this.reservation.start_datetime = startTime\n            this.reservation.end_datetime = endTime\n            \n            console.log('覆盖后的显示时间:', this.reservation.start_datetime, this.reservation.end_datetime)\n          }\n          \n          // 添加详细日志，帮助调试状态判断\n          console.log('Status from API:', this.reservation.status)\n          console.log('Current time:', new Date())\n          \n          // 确保状态字段正确\n          if (!this.reservation.status) {\n            // 如果API返回的状态为空，默认设置为confirmed\n            console.warn('API returned empty status, setting default to confirmed')\n            this.reservation.status = 'confirmed'\n          }\n          \n          // 重要：确保状态字段是正确的\n          console.log(`最终数据库状态: ${this.reservation.status}，展示状态为: ${this.getStatusText(this.reservation)}`)\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.reservationNotFound')\n          this.$message.error(errorMsg)\n          this.reservation = null\n        }\n      } catch (error) {\n        console.error('Failed to fetch reservation:', error)\n        this.$message.error(this.$t('error.serverError'))\n        this.reservation = null\n      } finally {\n        this.loading = false\n      }\n    },\n\n    formatDateTime(dateString) {\n      if (!dateString) return '-'\n\n      const date = new Date(dateString)\n      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`\n    },\n\n    // 获取状态文本\n    getStatusText(reservation) {\n      // 首先检查状态是否直接来自API响应\n      console.log('Checking status from API:', reservation.status);\n      \n      // 如果API明确返回了cancelled状态，显示已取消\n      if (reservation.status === 'cancelled') {\n        console.log('Using cancelled status from API');\n        return this.$t('reservation.cancelled');\n      }\n      \n      // 其他状态根据时间动态计算\n      if (isReservationExpired(reservation.end_datetime)) {\n        console.log('Calculated status: expired');\n        return this.$t('reservation.expired');\n      }\n\n      // 如果预约正在进行中，显示\"使用中\"\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        console.log('Calculated status: in use');\n        return this.$t('reservation.inUse');\n      }\n\n      // 如果预约已确认且未开始，显示\"已确认\"\n      console.log('Calculated status: confirmed');\n      return this.$t('reservation.confirmed');\n    },\n\n    // 获取状态类型（样式）\n    getStatusType(reservation) {\n      // 首先检查状态是否直接来自API响应\n      if (reservation.status === 'cancelled') {\n        return 'danger';\n      }\n\n      // 如果预约已过期，返回橙色\n      if (isReservationExpired(reservation.end_datetime)) {\n        return 'warning';\n      }\n\n      // 如果预约正在进行中，返回蓝色\n      const now = new Date();\n      const start = new Date(reservation.start_datetime);\n      const end = new Date(reservation.end_datetime);\n      if (now >= start && now <= end) {\n        return 'primary';\n      }\n\n      // 如果预约已确认且未开始，返回绿色\n      return 'success';\n    },\n\n    // 判断预约是否正在进行中\n    isReservationInProgress(reservation) {\n      if (!reservation) return false\n\n      const now = new Date()\n      const start = new Date(reservation.start_datetime)\n      const end = new Date(reservation.end_datetime)\n\n      // 当前时间在开始时间和结束时间之间\n      return now >= start && now <= end\n    },\n\n    handleCancel() {\n      this.cancelDialogVisible = true\n    },\n\n    handleReturn() {\n      this.returnDialogVisible = true\n    },\n\n    async confirmCancel() {\n      this.submitting = true\n\n      try {\n        // 检查是否是循环预约的子预约\n        if (this.reservation.recurring_reservation_id) {\n          console.log('Cancelling a child reservation of recurring reservation:', this.reservation.recurring_reservation_id)\n\n          // 获取当前预约的详细信息\n          const reservationCode = this.reservation.reservation_code\n\n          // 取消单个子预约\n          const response = await reservationApi.cancelReservation(reservationCode)\n\n          console.log('Cancel child reservation response:', response)\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n              \n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n              \n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled'\n              \n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled')\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'))\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm(\n                '已成功取消此子预约。是否查看循环预约详情？',\n                '操作成功',\n                {\n                  confirmButtonText: '查看循环预约',\n                  cancelButtonText: '留在当前页面',\n                  type: 'success'\n                }\n              ).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`)\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation()\n              })\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n              \n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled'\n              \n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled')\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'))\n\n              // 提示用户返回循环预约详情页面\n              this.$confirm(\n                '已成功取消此子预约。是否查看循环预约详情？',\n                '操作成功',\n                {\n                  confirmButtonText: '查看循环预约',\n                  cancelButtonText: '留在当前页面',\n                  type: 'success'\n                }\n              ).then(() => {\n                // 跳转到循环预约详情页面\n                this.$router.push(`/admin/recurring-reservation/${this.reservation.recurring_reservation_id}`)\n              }).catch(() => {\n                // 用户选择留在当前页面，直接重新获取预定信息\n                this.fetchReservation()\n              })\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed')\n              this.$message.error(errorMsg)\n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n            }\n          }\n        } else {\n          // 普通预约的取消逻辑\n          const response = await reservationApi.cancelReservation(this.reservation.reservation_code)\n\n          console.log('Cancel response:', response)\n\n          // 无论API响应成功与否，检查返回消息以确定实际状态\n          if (response.data) {\n            // 特殊处理：如果消息表明预定已经取消，视为成功\n            if (response.data.message === '预定已取消' || response.data.message.includes('已取消')) {\n              console.log('预定已经处于取消状态，视为取消成功');\n              \n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n              \n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled'\n              \n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled')\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'))\n              \n              // 直接重新获取预定信息（为了更新其他可能的字段）\n              this.fetchReservation()\n              return;\n            } else if (response.data.success) {\n              // 常规成功响应处理\n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n              \n              // 立即更新预约状态，不等待API重新获取\n              this.reservation.status = 'cancelled'\n              \n              // 立即更新UI显示的状态\n              this.forceUpdateStatus('cancelled')\n\n              // 显示成功消息\n              this.$message.success(this.$t('reservation.cancelSuccess'))\n              \n              // 直接重新获取预定信息（为了更新其他可能的字段）\n              this.fetchReservation()\n            } else {\n              // 真正的错误消息\n              const errorMsg = response.data.message || this.$t('reservation.cancelFailed')\n              this.$message.error(errorMsg)\n              // 关闭取消对话框\n              this.cancelDialogVisible = false\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Failed to cancel reservation:', error)\n        this.$message.error(this.$t('error.serverError'))\n        // 关闭取消对话框\n        this.cancelDialogVisible = false\n      } finally {\n        this.submitting = false\n      }\n    },\n\n    async confirmReturn() {\n      this.submitting = true\n\n      try {\n        // 使用取消预定的API，但添加early_return参数\n        const response = await reservationApi.cancelReservation(this.reservation.reservation_code, {\n          early_return: true\n        })\n\n        console.log('Return response:', response)\n\n        if (response.data && response.data.success) {\n          // 关闭对话框\n          this.returnDialogVisible = false\n\n          // 显示成功消息\n          this.$message.success(this.$t('reservation.returnSuccess'))\n\n          // 直接重新获取预定信息\n          this.fetchReservation()\n        } else {\n          const errorMsg = response.data ? response.data.message : this.$t('reservation.returnFailed')\n          this.$message.error(errorMsg)\n          this.returnDialogVisible = false\n        }\n      } catch (error) {\n        console.error('Failed to return equipment:', error)\n        this.$message.error(this.$t('error.serverError'))\n        this.returnDialogVisible = false\n      } finally {\n        this.submitting = false\n      }\n    },\n\n    goBack() {\n      // 使用浏览器的历史记录返回，而不是直接跳转\n      if (window.history.length > 1) {\n        this.$router.go(-1); // 返回上一页\n      } else {\n        // 如果没有历史记录，则导航到预定管理页面\n        this.$router.push('/admin/reservation');\n      }\n    },\n\n    // 状态保存相关方法\n    saveState() {\n      if (!this.reservation) return\n      \n      // 计算当前状态\n      const statusText = this.getStatusText(this.reservation)\n      const statusType = this.getStatusType(this.reservation)\n      \n      // 将状态保存到localStorage\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`\n      const state = {\n        statusText,\n        statusType,\n        timestamp: new Date().getTime()\n      }\n      \n      console.log('Saving state to localStorage:', state)\n      localStorage.setItem(stateKey, JSON.stringify(state))\n    },\n    \n    getSavedState() {\n      if (!this.reservation) return null\n      \n      // 从localStorage获取状态\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`\n      const savedStateStr = localStorage.getItem(stateKey)\n      \n      if (!savedStateStr) return null\n      \n      try {\n        const savedState = JSON.parse(savedStateStr)\n        console.log('Retrieved saved state:', savedState)\n        \n        // 检查保存的状态是否过期（超过5分钟）\n        const now = new Date().getTime()\n        const fiveMinutes = 5 * 60 * 1000\n        if (now - savedState.timestamp > fiveMinutes) {\n          console.log('Saved state is expired, removing it')\n          localStorage.removeItem(stateKey)\n          return null\n        }\n        \n        return savedState\n      } catch (e) {\n        console.error('Error parsing saved state:', e)\n        return null\n      }\n    },\n\n    // 更新URL中的状态参数\n    updateUrlWithNewStatus(newStatus) {\n      console.log('更新URL状态为:', newStatus);\n      \n      // 获取当前状态对应的文本和类型\n      let statusText = '';\n      let statusType = '';\n      \n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        \n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n      }\n      \n      console.log('新状态文本和类型:', statusText, statusType);\n      \n      // 更新路由参数，但不触发路由变化\n      const query = { ...this.$route.query, displayStatus: statusText, displayStatusType: statusType };\n      \n      // 更新URL但不重新加载页面\n      this.$router.replace({ \n        path: this.$route.path, \n        query \n      }).catch(err => {\n        // 忽略重复导航错误\n        if (err.name !== 'NavigationDuplicated') {\n          throw err;\n        }\n      });\n    },\n\n    // 强制更新状态显示（用于操作后立即更新UI）\n    forceUpdateStatus(newStatus) {\n      console.log('强制更新状态为:', newStatus);\n      \n      // 更新状态文本和类型\n      let statusText = '';\n      let statusType = '';\n      \n      if (newStatus === 'cancelled') {\n        statusText = this.$t('reservation.cancelled');\n        statusType = 'danger';\n      } else if (newStatus === 'confirmed') {\n        const now = new Date();\n        const start = new Date(this.reservation.start_datetime);\n        const end = new Date(this.reservation.end_datetime);\n        \n        if (now >= start && now <= end) {\n          // 使用中\n          statusText = this.$t('reservation.inUse');\n          statusType = 'primary';\n        } else if (isReservationExpired(this.reservation.end_datetime)) {\n          // 已过期\n          statusText = this.$t('reservation.expired');\n          statusType = 'warning';\n        } else {\n          // 已确认\n          statusText = this.$t('reservation.confirmed');\n          statusType = 'success';\n        }\n      }\n      \n      console.log('强制更新后的状态文本和类型:', statusText, statusType);\n      \n      // 直接设置强制状态值，立即更新UI\n      this.forcedStatusText = statusText;\n      this.forcedStatusType = statusType;\n      \n      // 保存到本地存储，确保刷新页面后状态保持一致\n      const stateKey = `reservation_status_${this.reservation.reservation_code}`;\n      const state = {\n        statusText,\n        statusType,\n        timestamp: new Date().getTime()\n      };\n      localStorage.setItem(stateKey, JSON.stringify(state));\n      \n      // 直接替换URL参数，但不触发路由变化\n      const query = { \n        ...this.$route.query, \n        displayStatus: statusText, \n        displayStatusType: statusType \n      };\n      \n      // 替换URL参数\n      this.$router.replace({ \n        path: this.$route.path, \n        query \n      }).catch(err => {\n        // 忽略重复导航错误\n        if (err.name !== 'NavigationDuplicated') {\n          throw err;\n        }\n      });\n    },\n\n    // 检查URL时间参数是否与预定时间匹配\n    isTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      \n      console.log('比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n      \n      // 将所有时间转换为字符串以便比较\n      const formatTime = (timeStr) => {\n        try {\n          // 处理可能的日期格式\n          const date = new Date(timeStr);\n          if (isNaN(date.getTime())) {\n            // 如果无法解析为日期，直接使用原始字符串\n            return timeStr;\n          }\n          \n          // 将日期格式化为 YYYY-MM-DD 的形式\n          const year = date.getFullYear();\n          const month = String(date.getMonth() + 1).padStart(2, '0');\n          const day = String(date.getDate()).padStart(2, '0');\n          \n          // 返回日期部分，用于匹配同一天的不同预定\n          return `${year}-${month}-${day}`;\n        } catch (e) {\n          console.error('格式化时间出错:', e);\n          return timeStr;\n        }\n      };\n      \n      const urlStartFormatted = formatTime(urlStartTime);\n      const urlEndFormatted = formatTime(urlEndTime);\n      const resStartFormatted = formatTime(resStartTime);\n      const resEndFormatted = formatTime(resEndTime);\n      \n      console.log('格式化后的时间比较:', {\n        urlStartFormatted,\n        urlEndFormatted,\n        resStartFormatted,\n        resEndFormatted\n      });\n      \n      // 判断日期是否匹配（只比较日期部分）\n      const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n      \n      console.log('时间匹配结果:', isMatch);\n      \n      return isMatch;\n    },\n\n    // 检查URL时间参数是否与预定时间精确匹配（包括时间部分）\n    isExactTimeMatching(urlStartTime, urlEndTime, resStartTime, resEndTime) {\n      if (!urlStartTime || !urlEndTime || !resStartTime || !resEndTime) {\n        return false;\n      }\n      \n      console.log('精确比较时间参数:', {\n        urlStartTime,\n        urlEndTime,\n        resStartTime,\n        resEndTime\n      });\n      \n      try {\n        // 尝试解析日期时间，转换为ISO格式进行精确比较\n        // 注意：我们需要比较的是时间精度而不仅仅是日期\n        \n        // 处理URL中的时间参数\n        let urlStart, urlEnd;\n        if (typeof urlStartTime === 'string') {\n          // 如果是ISO格式字符串，直接创建Date对象\n          if (urlStartTime.includes('T')) {\n            urlStart = new Date(urlStartTime);\n          } else {\n            // 如果是\"YYYY-MM-DD HH:MM\"格式，手动解析\n            const parts = urlStartTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlStart = new Date(\n                parseInt(dateParts[0]), \n                parseInt(dateParts[1]) - 1, // 月份是0-11\n                parseInt(dateParts[2]),\n                parseInt(timeParts[0]),\n                parseInt(timeParts[1])\n              );\n            } else {\n              urlStart = new Date(urlStartTime);\n            }\n          }\n        } else {\n          urlStart = new Date(urlStartTime);\n        }\n        \n        if (typeof urlEndTime === 'string') {\n          if (urlEndTime.includes('T')) {\n            urlEnd = new Date(urlEndTime);\n          } else {\n            const parts = urlEndTime.split(' ');\n            if (parts.length === 2) {\n              const dateParts = parts[0].split('-');\n              const timeParts = parts[1].split(':');\n              urlEnd = new Date(\n                parseInt(dateParts[0]), \n                parseInt(dateParts[1]) - 1,\n                parseInt(dateParts[2]),\n                parseInt(timeParts[0]),\n                parseInt(timeParts[1])\n              );\n            } else {\n              urlEnd = new Date(urlEndTime);\n            }\n          }\n        } else {\n          urlEnd = new Date(urlEndTime);\n        }\n        \n        // 处理预约中的时间\n        let resStart = new Date(resStartTime);\n        let resEnd = new Date(resEndTime);\n        \n        // 将所有时间转换为ISO字符串进行比较（不包括毫秒和时区信息）\n        const formatForCompare = (date) => {\n          if (isNaN(date.getTime())) {\n            console.error('无效的日期对象:', date);\n            return '';\n          }\n          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n        };\n        \n        const urlStartFormatted = formatForCompare(urlStart);\n        const urlEndFormatted = formatForCompare(urlEnd);\n        const resStartFormatted = formatForCompare(resStart);\n        const resEndFormatted = formatForCompare(resEnd);\n        \n        console.log('格式化后的精确时间比较:', {\n          urlStartFormatted,\n          urlEndFormatted,\n          resStartFormatted,\n          resEndFormatted\n        });\n        \n        // 判断时间是否精确匹配\n        const isMatch = urlStartFormatted === resStartFormatted && urlEndFormatted === resEndFormatted;\n        \n        console.log('精确时间匹配结果:', isMatch);\n        \n        return isMatch;\n      } catch (e) {\n        console.error('精确比较时间出错:', e);\n        // 出错时保守返回不匹配\n        return false;\n      }\n    },\n  }\n}\n</script>\n\n<style scoped>\n.admin-reservation-detail {\n  padding: 20px;\n}\n\n.page-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n}\n\n.page-title {\n  margin: 0;\n  font-size: 24px;\n  color: #303133;\n}\n\n.loading-container {\n  padding: 40px 0;\n}\n\n.error-card {\n  text-align: center;\n  padding: 40px 0;\n}\n\n.error-message {\n  margin-bottom: 20px;\n}\n\n.error-message i {\n  font-size: 48px;\n  color: #E6A23C;\n  margin-bottom: 10px;\n}\n\n.error-message p {\n  font-size: 18px;\n  color: #606266;\n}\n\n.detail-card {\n  margin-bottom: 20px;\n}\n\n.card-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.actions {\n  margin-top: 20px;\n  text-align: right;\n}\n\n@media (max-width: 768px) {\n  .el-descriptions-item {\n    width: 100%;\n  }\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}