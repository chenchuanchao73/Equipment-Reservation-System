{"ast":null,"code":"import Vue from 'vue';\nimport { Calendar } from '@fullcalendar/core';\nimport { CustomRenderingStore } from '@fullcalendar/core/internal';\nimport { OPTION_IS_COMPLEX } from './options.js';\nimport OffscreenFragment from './OffscreenFragment.js';\nimport TransportContainer from './TransportContainer.js';\nconst FullCalendar = Vue.extend({\n  props: {\n    options: Object\n  },\n  data() {\n    return {\n      renderId: 0,\n      customRenderingMap: new Map()\n    };\n  },\n  methods: {\n    getApi() {\n      return getSecret(this).calendar;\n    },\n    buildOptions(suppliedOptions) {\n      return Object.assign(Object.assign({}, suppliedOptions), {\n        customRenderingMetaMap: kebabToCamelKeys(this.$scopedSlots),\n        handleCustomRendering: getSecret(this).handleCustomRendering,\n        customRenderingReplaces: true\n      });\n    }\n  },\n  render(h) {\n    const customRenderingNodes = [];\n    for (const customRendering of this.customRenderingMap.values()) {\n      const innerContent = typeof customRendering.generatorMeta === 'function' ? customRendering.generatorMeta(customRendering.renderProps) :\n      // a slot-render-function\n      customRendering.generatorMeta; // jsx vnode?\n      customRenderingNodes.push(\n      // need stable element reference for list-diffing\n      // TODO: move this functionality within TransportContainer\n      h('div', {\n        key: customRendering.id\n      }, [h(TransportContainer, {\n        key: customRendering.id,\n        props: {\n          inPlaceOf: customRendering.containerEl,\n          reportEl: customRendering.reportNewContainerEl,\n          elTag: customRendering.elTag,\n          elClasses: customRendering.elClasses,\n          elStyle: customRendering.elStyle,\n          elAttrs: customRendering.elAttrs\n        }\n      }, innerContent)]));\n    }\n    return h('div', {\n      // when renderId is changed, Vue will trigger a real-DOM async rerender, calling beforeUpdate/updated\n      attrs: {\n        'data-fc-render-id': this.renderId\n      }\n    }, [\n    // for containing TransportContainer keys\n    h(OffscreenFragment, customRenderingNodes)]);\n  },\n  mounted() {\n    const customRenderingStore = new CustomRenderingStore();\n    getSecret(this).handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);\n    const calendarOptions = this.buildOptions(this.options);\n    const calendar = new Calendar(this.$el, calendarOptions);\n    getSecret(this).calendar = calendar;\n    calendar.render();\n    customRenderingStore.subscribe(customRenderingMap => {\n      this.customRenderingMap = customRenderingMap; // likely same reference, so won't rerender\n      this.renderId++; // force rerender\n      getSecret(this).needCustomRenderingResize = true;\n    });\n  },\n  beforeUpdate() {\n    this.getApi().resumeRendering(); // the watcher handlers paused it\n  },\n  updated() {\n    if (getSecret(this).needCustomRenderingResize) {\n      getSecret(this).needCustomRenderingResize = false;\n      this.getApi().updateSize();\n    }\n  },\n  beforeDestroy() {\n    this.getApi().destroy();\n  },\n  watch: buildWatchers()\n});\nexport default FullCalendar;\n// storing internal state:\n// https://github.com/vuejs/vue/issues/1988#issuecomment-163013818\nfunction getSecret(inst) {\n  return inst;\n}\nfunction buildWatchers() {\n  let watchers = {\n    // watches changes of ALL options and their nested objects,\n    // but this is only a means to be notified of top-level non-complex options changes.\n    options: {\n      deep: true,\n      handler(options) {\n        let calendar = this.getApi();\n        calendar.pauseRendering();\n        let calendarOptions = this.buildOptions(options);\n        calendar.resetOptions(calendarOptions);\n        this.renderId++; // will queue a rerender\n      }\n    }\n  };\n  for (let complexOptionName in OPTION_IS_COMPLEX) {\n    // handlers called when nested objects change\n    watchers[`options.${complexOptionName}`] = {\n      deep: true,\n      handler(val) {\n        // unfortunately the handler is called with undefined if new props were set, but the complex one wasn't ever set\n        if (val !== undefined) {\n          let calendar = this.getApi();\n          calendar.pauseRendering();\n          calendar.resetOptions({\n            [complexOptionName]: val\n          }, [complexOptionName]);\n          this.renderId++; // will queue a rerender\n        }\n      }\n    };\n  }\n  return watchers;\n}\n// General Utils\nfunction kebabToCamelKeys(map) {\n  const newMap = {};\n  for (const key in map) {\n    newMap[kebabToCamel(key)] = map[key];\n  }\n  return newMap;\n}\nfunction kebabToCamel(s) {\n  return s.split('-').map((word, index) => index ? capitalize(word) : word).join('');\n}\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}