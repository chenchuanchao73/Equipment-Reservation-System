{"ast":null,"code":"import { reservationApi } from '@/api';\nimport { isReservationExpired } from '@/utils/date';\nexport default {\n  name: 'AdminReservation',\n  data() {\n    return {\n      loading: false,\n      reservations: [],\n      total: 0,\n      currentPage: 1,\n      pageSize: 10,\n      filter: {\n        code: '',\n        userName: '',\n        status: '',\n        dateRange: []\n      },\n      // 添加一个保存页面状态的变量\n      savedState: null\n    };\n  },\n  created() {\n    // 检查是否有保存的状态并恢复它\n    this.restoreState();\n  },\n  // 添加activated钩子函数，在组件被激活时调用（如从预定详情页面返回）\n  activated() {\n    // 检查是否需要强制刷新\n    const forceRefresh = localStorage.getItem('force_refresh_reservation_list');\n    if (forceRefresh === 'true') {\n      console.log('检测到强制刷新标记，重新获取数据');\n      localStorage.removeItem('force_refresh_reservation_list');\n      this.fetchData();\n      return;\n    }\n\n    // 当从其他页面返回时，尝试恢复状态\n    this.restoreState();\n    // 检查预约状态更新\n    this.checkReservationUpdates();\n  },\n  // 添加deactivated钩子函数，在组件被停用时调用（如进入预定详情页面）\n  deactivated() {\n    // 保存当前页面状态\n    this.saveState();\n  },\n  // 添加beforeRouteLeave导航守卫，在离开组件时调用\n  beforeRouteLeave(to, from, next) {\n    // 如果是跳转到预定详情页面，保存状态\n    if (to.path.includes('/admin/reservation/') && to.path !== '/admin/reservation') {\n      this.saveState();\n    }\n    next();\n  },\n  methods: {\n    async fetchData() {\n      this.loading = true;\n      console.log('Fetching data with filter:', this.filter);\n      console.log('Current page:', this.currentPage);\n      try {\n        // 添加时间戳参数，确保每次都获取最新数据\n        const timestamp = new Date().getTime();\n        console.log('添加时间戳参数:', timestamp);\n        const params = {\n          skip: (this.currentPage - 1) * this.pageSize,\n          // 将页码转换为skip参数\n          limit: this.pageSize,\n          reservation_code: this.filter.code || undefined,\n          user_name: this.filter.userName || undefined,\n          _t: timestamp,\n          // 添加时间戳，防止缓存\n          sort_by: 'id',\n          // 按ID排序\n          sort_order: 'desc' // 降序排序\n        };\n\n        // 添加日期范围过滤\n        if (this.filter.dateRange && this.filter.dateRange.length === 2) {\n          params.from_date = this.filter.dateRange[0];\n          params.to_date = this.filter.dateRange[1];\n        }\n\n        // 处理不同的状态筛选\n        if (this.filter.status) {\n          console.log('Filtering by status:', this.filter.status);\n\n          // 直接使用选择的状态值，因为后端现在支持所有状态\n          params.status = this.filter.status;\n          console.log(`Setting status parameter to \"${this.filter.status}\"`);\n        }\n        console.log('Fetching reservations with params:', params);\n        const response = await reservationApi.getReservations(params);\n        console.log('API Response:', response);\n        let reservations = response.data.items || [];\n        console.log('Received reservations:', reservations);\n\n        // 不再需要在前端进行筛选，因为后端已经返回了正确的状态\n        // 只记录日志，帮助调试\n        if (this.filter.status) {\n          console.log(`获取到状态为 ${this.filter.status} 的预约数量: ${reservations.length}`);\n\n          // 记录每个预约的状态，帮助调试\n          reservations.forEach(reservation => {\n            console.log(`预约ID=${reservation.id}, 状态=${reservation.status}, 开始时间=${reservation.start_datetime}, 结束时间=${reservation.end_datetime}`);\n          });\n        }\n        console.log('Filtered reservations:', reservations);\n        this.reservations = reservations;\n\n        // 如果是特殊状态，总数需要重新计算\n        if (this.filter.status === 'in_use' || this.filter.status === 'expired' || this.filter.status === 'confirmed' || this.filter.status === 'cancelled') {\n          // 对于特殊状态，我们需要获取所有页的数据来计算总数\n          // 这里我们先使用当前页的数据计算一个临时总数\n          this.total = reservations.length;\n          console.log(`Temporary total based on current page: ${this.total}`);\n\n          // 无论当前页是否有数据，都获取所有数据来计算真实总数\n          this.fetchTotalForSpecialStatus();\n        } else {\n          this.total = response.data.total;\n          console.log(`Total from API response: ${this.total}`);\n        }\n      } catch (error) {\n        console.error('Failed to fetch reservations:', error);\n        this.$message.error(this.$t('error.serverError'));\n      } finally {\n        this.loading = false;\n      }\n    },\n    formatDateTime(_row, _column, cellValue) {\n      if (!cellValue) return '';\n      const date = new Date(cellValue);\n      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;\n    },\n    getStatusType(reservation) {\n      // 直接根据后端返回的状态返回对应的类型\n      switch (reservation.status) {\n        case 'cancelled':\n          return 'danger';\n        // 已取消 - 红色\n        case 'expired':\n          return 'warning';\n        // 已过期 - 橙色\n        case 'in_use':\n          return 'primary';\n        // 使用中 - 蓝色\n        case 'confirmed':\n          return 'success';\n        // 已确认 - 绿色\n        default:\n          return 'info';\n        // 其他状态 - 灰色\n      }\n    },\n    getStatusText(reservation) {\n      // 直接根据后端返回的状态返回对应的文本\n      switch (reservation.status) {\n        case 'cancelled':\n          return this.$t('reservation.statusCancelled');\n        // 已取消\n        case 'expired':\n          return this.$t('reservation.statusExpired');\n        // 已过期\n        case 'in_use':\n          return this.$t('reservation.statusInUse');\n        // 使用中\n        case 'confirmed':\n          return this.$t('reservation.statusConfirmed');\n        // 已确认\n        default:\n          return reservation.status;\n        // 其他状态直接显示\n      }\n    },\n    handleFilterChange() {\n      this.currentPage = 1;\n      this.fetchData();\n    },\n    resetFilter() {\n      this.filter = {\n        code: '',\n        userName: '',\n        status: '',\n        dateRange: []\n      };\n      this.handleFilterChange();\n    },\n    handlePageChange(page) {\n      this.currentPage = page;\n      this.fetchData();\n    },\n    viewReservation(reservation) {\n      // 计算当前预约的实际状态文本和类型\n      const statusText = this.getStatusText(reservation);\n      const statusType = this.getStatusType(reservation);\n      console.log('计算的状态信息:', {\n        statusText,\n        statusType,\n        dbStatus: reservation.status,\n        startTime: reservation.start_datetime,\n        endTime: reservation.end_datetime,\n        reservationNumber: reservation.reservation_number\n      });\n\n      // 构建URL，添加预约码、时间参数、预约序号和计算好的状态信息\n      // 使用预约序号作为路径参数，而不是预约码\n      const url = {\n        path: `/admin/reservation/${reservation.reservation_code}`,\n        query: {\n          startTime: reservation.start_datetime,\n          endTime: reservation.end_datetime,\n          displayStatus: statusText,\n          displayStatusType: statusType,\n          reservationNumber: reservation.reservation_number // 添加预约序号参数\n        }\n      };\n\n      // 每次查看预约时，都重新设置一个标记，表示需要显示预约序号通知\n      localStorage.setItem('show_reservation_number_notification', 'true');\n\n      // 清除之前的预约序号，确保每次都使用新的预约序号\n      localStorage.removeItem('current_reservation_number');\n\n      // 将预约序号保存到localStorage，以便在页面刷新后仍然可以使用\n      if (reservation.reservation_number) {\n        localStorage.setItem('current_reservation_number', reservation.reservation_number);\n        console.log('保存预约序号到localStorage:', reservation.reservation_number);\n\n        // 强制使用预约序号查询，而不是预约码\n        localStorage.setItem('force_use_reservation_number', 'true');\n      }\n      this.$router.push(url);\n    },\n    // 获取特殊状态的总记录数并更新当前页面的预约列表\n    async fetchTotalForSpecialStatus() {\n      try {\n        console.log('Fetching total for special status:', this.filter.status);\n        console.log('Current page before fetchTotal:', this.currentPage);\n\n        // 保存当前页码，以便后续恢复\n        const savedCurrentPage = this.currentPage;\n\n        // 添加时间戳参数，确保每次都获取最新数据\n        const timestamp = new Date().getTime();\n        console.log('添加时间戳参数:', timestamp);\n\n        // 构建查询参数，不包含分页参数\n        const params = {\n          // 不设置limit，获取所有记录\n          limit: 1000,\n          // 设置一个较大的值以获取尽可能多的记录\n          skip: 0,\n          reservation_code: this.filter.code || undefined,\n          // 使用reservation_code而不是code\n          user_name: this.filter.userName || undefined,\n          _t: timestamp,\n          // 添加时间戳，防止缓存\n          sort_by: 'id',\n          // 按ID排序\n          sort_order: 'desc' // 降序排序\n        };\n\n        // 添加日期范围过滤\n        if (this.filter.dateRange && this.filter.dateRange.length === 2) {\n          params.from_date = this.filter.dateRange[0];\n          params.to_date = this.filter.dateRange[1];\n        }\n\n        // 直接获取指定状态的预约\n        const statusParams = {\n          ...params,\n          status: this.filter.status\n        };\n        console.log(`直接获取状态为 ${this.filter.status} 的预约`);\n        const response = await reservationApi.getReservations(statusParams);\n\n        // 使用后端返回的结果\n        let allReservations = response.data.items || [];\n        console.log(`Total reservations before filtering: ${allReservations.length}`);\n        const now = new Date();\n        console.log(`当前日期: ${now}`);\n\n        // 不再需要在前端进行筛选，因为后端已经返回了正确的状态\n        // 只记录日志，帮助调试\n        console.log(`获取到状态为 ${this.filter.status} 的预约数量: ${allReservations.length}`);\n\n        // 记录每个预约的状态，帮助调试\n        allReservations.forEach(reservation => {\n          console.log(`预约ID=${reservation.id}, 状态=${reservation.status}, 开始时间=${reservation.start_datetime}, 结束时间=${reservation.end_datetime}`);\n        });\n\n        // 更新总数\n        this.total = allReservations.length;\n        console.log(`Updated total to: ${this.total}`);\n\n        // 对筛选后的结果进行排序\n        if (this.filter.status === 'expired') {\n          // 对于已过期，按结束时间倒序排列\n          allReservations.sort((a, b) => new Date(b.end_datetime) - new Date(a.end_datetime));\n        } else if (this.filter.status === 'in_use') {\n          // 对于使用中，按开始时间倒序排列\n          allReservations.sort((a, b) => new Date(b.start_datetime) - new Date(a.start_datetime));\n        } else if (this.filter.status === 'confirmed') {\n          // 对于已确认，按开始时间升序排列\n          allReservations.sort((a, b) => new Date(a.start_datetime) - new Date(b.start_datetime));\n        } else if (this.filter.status === 'cancelled') {\n          // 对于已取消，按结束时间倒序排列\n          allReservations.sort((a, b) => new Date(b.end_datetime) - new Date(a.end_datetime));\n        }\n\n        // 计算当前页应该显示的预约\n        const maxPage = Math.ceil(allReservations.length / this.pageSize) || 1;\n\n        // 确保页码不超过最大页数\n        const targetPage = Math.min(savedCurrentPage, maxPage);\n        console.log(`计算页数: 总记录数=${allReservations.length}, 每页记录数=${this.pageSize}, 最大页数=${maxPage}, 目标页码=${targetPage}`);\n        const startIndex = (targetPage - 1) * this.pageSize;\n        const endIndex = Math.min(startIndex + this.pageSize, allReservations.length);\n        const currentPageReservations = allReservations.slice(startIndex, endIndex);\n        console.log(`当前页数据范围: 开始索引=${startIndex}, 结束索引=${endIndex}, 当前页记录数=${currentPageReservations.length}`);\n\n        // 更新当前页面的预约列表\n        if (currentPageReservations.length > 0) {\n          // 先更新数据\n          this.reservations = currentPageReservations;\n          // 然后更新页码，避免触发不必要的重新获取数据\n          if (this.currentPage !== targetPage) {\n            console.log(`更新页码: 从 ${this.currentPage} 到 ${targetPage}`);\n            this.$nextTick(() => {\n              this.currentPage = targetPage;\n            });\n          }\n          console.log(`更新当前页面的预约列表: ${this.reservations.length} 条记录`);\n        } else if (allReservations.length > 0) {\n          // 如果当前页没有数据但总数据不为空，自动回到第一页\n          console.log(`当前页没有数据，回到第一页`);\n          this.reservations = allReservations.slice(0, this.pageSize);\n          if (this.currentPage !== 1) {\n            this.$nextTick(() => {\n              this.currentPage = 1;\n            });\n          }\n        } else {\n          // 如果没有找到任何预约\n          this.reservations = [];\n          console.log('没有找到符合条件的预约');\n        }\n        console.log('Current page after fetchTotal:', this.currentPage);\n      } catch (error) {\n        console.error('Failed to fetch total for special status:', error);\n      }\n    },\n    // 保存当前页面状态\n    saveState() {\n      this.savedState = {\n        filter: {\n          ...this.filter\n        },\n        currentPage: this.currentPage\n      };\n      console.log('Saved state:', this.savedState);\n    },\n    // 恢复保存的页面状态\n    restoreState() {\n      if (this.savedState) {\n        this.filter = {\n          ...this.savedState.filter\n        };\n        this.currentPage = this.savedState.currentPage;\n        console.log('Restored state:', this.savedState);\n        this.fetchData();\n      } else {\n        this.fetchData();\n      }\n    },\n    // 打开预约详情\n    openReservationDetail(reservation) {\n      console.log('打开预约详情:', reservation);\n\n      // 计算当前状态\n      const statusText = this.getStatusText(reservation);\n      const statusType = this.getStatusType(reservation);\n      const dbStatus = reservation.status || 'confirmed';\n      const startTime = reservation.start_datetime;\n      const endTime = reservation.end_datetime;\n      console.log('计算的状态信息:', {\n        statusText,\n        statusType,\n        dbStatus,\n        startTime,\n        endTime\n      });\n\n      // 将状态保存到localStorage，以便详情页面使用\n      const stateKey = `reservation_status_${reservation.reservation_code}`;\n      const state = {\n        statusText,\n        statusType,\n        dbStatus,\n        timestamp: new Date().getTime()\n      };\n      console.log('Saved state:', state);\n      localStorage.setItem(stateKey, JSON.stringify(state));\n\n      // 导航到详情页面，并传递状态和时间参数\n      this.$router.push({\n        name: 'AdminReservationDetail',\n        params: {\n          code: reservation.reservation_code\n        },\n        query: {\n          displayStatus: statusText,\n          displayStatusType: statusType,\n          startTime: startTime,\n          endTime: endTime\n        }\n      });\n    },\n    // 在激活（从其他页面返回）时，检查预约状态是否需要更新\n    async checkReservationUpdates() {\n      // 如果当前显示的是预约列表，则检查是否需要刷新\n      if (this.reservations.length > 0) {\n        // 检查localStorage中是否有任何预约状态发生了变化\n        for (let i = 0; i < this.reservations.length; i++) {\n          const reservation = this.reservations[i];\n          const stateKey = `reservation_status_${reservation.reservation_code}`;\n          const savedStateStr = localStorage.getItem(stateKey);\n          if (savedStateStr) {\n            try {\n              const savedState = JSON.parse(savedStateStr);\n\n              // 检查保存的状态是否还是新鲜的（5分钟内）\n              const now = new Date().getTime();\n              const fiveMinutes = 5 * 60 * 1000;\n              if (now - savedState.timestamp <= fiveMinutes) {\n                console.log(`检测到预约 ${reservation.reservation_code} 的状态可能已更改，保存的状态:`, savedState);\n\n                // 检查是否有强制状态更新，特别是已取消状态\n                if (savedState.forcedStatus === 'cancelled' || savedState.statusText === this.$t('reservation.cancelled') && savedState.statusType === 'danger') {\n                  console.log(`预约 ${reservation.reservation_code} 已被标记为已取消，将在界面上更新`);\n\n                  // 更新当前列表中的预约状态\n                  this.reservations[i].status = 'cancelled';\n\n                  // 强制更新UI\n                  this.$forceUpdate();\n                }\n              } else {\n                // 如果状态过期，则移除它\n                console.log(`预约 ${reservation.reservation_code} 的保存状态已过期，移除`);\n                localStorage.removeItem(stateKey);\n              }\n            } catch (e) {\n              console.error('解析保存的状态时出错:', e);\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}